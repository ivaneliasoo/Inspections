/* tslint:disable */
/* eslint-disable */
/**
 * Inspections API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration'
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from './base'

/**
 *
 * @export
 * @interface AddCheckListCommand
 */
export interface AddCheckListCommand {
  /**
   *
   * @type {string}
   * @memberof AddCheckListCommand
   */
  text?: string | null
  /**
   *
   * @type {Array<CheckListItemDTO>}
   * @memberof AddCheckListCommand
   */
  items?: Array<CheckListItemDTO> | null
  /**
   *
   * @type {string}
   * @memberof AddCheckListCommand
   */
  annotation?: string | null
  /**
   *
   * @type {boolean}
   * @memberof AddCheckListCommand
   */
  isConfiguration?: boolean
}
/**
 *
 * @export
 * @interface AddCheckListItemCommand
 */
export interface AddCheckListItemCommand {
  /**
   *
   * @type {number}
   * @memberof AddCheckListItemCommand
   */
  idCheckList?: number
  /**
   *
   * @type {string}
   * @memberof AddCheckListItemCommand
   */
  text?: string | null
  /**
   *
   * @type {CheckValue}
   * @memberof AddCheckListItemCommand
   */
  checked?: CheckValue
  /**
   *
   * @type {boolean}
   * @memberof AddCheckListItemCommand
   */
  editable?: boolean
  /**
   *
   * @type {boolean}
   * @memberof AddCheckListItemCommand
   */
  required?: boolean
  /**
   *
   * @type {string}
   * @memberof AddCheckListItemCommand
   */
  remarks?: string | null
}
/**
 *
 * @export
 * @interface AddNoteCommand
 */
export interface AddNoteCommand {
  /**
   *
   * @type {number}
   * @memberof AddNoteCommand
   */
  reportId?: number
  /**
   *
   * @type {string}
   * @memberof AddNoteCommand
   */
  text?: string | null
  /**
   *
   * @type {boolean}
   * @memberof AddNoteCommand
   */
  checked?: boolean
  /**
   *
   * @type {boolean}
   * @memberof AddNoteCommand
   */
  needsCheck?: boolean
}
/**
 *
 * @export
 * @interface AddPrintSectionCommand
 */
export interface AddPrintSectionCommand {
  /**
   *
   * @type {string}
   * @memberof AddPrintSectionCommand
   */
  code?: string | null
  /**
   *
   * @type {string}
   * @memberof AddPrintSectionCommand
   */
  content?: string | null
  /**
   *
   * @type {string}
   * @memberof AddPrintSectionCommand
   */
  description?: string | null
  /**
   *
   * @type {boolean}
   * @memberof AddPrintSectionCommand
   */
  isMainReport?: boolean
  /**
   *
   * @type {PrintSectionStatus}
   * @memberof AddPrintSectionCommand
   */
  status?: PrintSectionStatus
}
/**
 *
 * @export
 * @interface AddReportConfigurationCommand
 */
export interface AddReportConfigurationCommand {
  /**
   *
   * @type {ReportType}
   * @memberof AddReportConfigurationCommand
   */
  type?: ReportType
  /**
   *
   * @type {string}
   * @memberof AddReportConfigurationCommand
   */
  title?: string | null
  /**
   *
   * @type {string}
   * @memberof AddReportConfigurationCommand
   */
  formName?: string | null
  /**
   *
   * @type {string}
   * @memberof AddReportConfigurationCommand
   */
  remarksLabelText?: string | null
  /**
   *
   * @type {Array<number>}
   * @memberof AddReportConfigurationCommand
   */
  checksDefinition?: Array<number> | null
  /**
   *
   * @type {Array<number>}
   * @memberof AddReportConfigurationCommand
   */
  signatureDefinitions?: Array<number> | null
  /**
   *
   * @type {CheckListDisplay}
   * @memberof AddReportConfigurationCommand
   */
  display?: CheckListDisplay
  /**
   *
   * @type {number}
   * @memberof AddReportConfigurationCommand
   */
  printSectionId?: number
  /**
   *
   * @type {string}
   * @memberof AddReportConfigurationCommand
   */
  templateName?: string | null
}
/**
 *
 * @export
 * @interface AddSignatureCommand
 */
export interface AddSignatureCommand {
  /**
   *
   * @type {string}
   * @memberof AddSignatureCommand
   */
  title?: string | null
  /**
   *
   * @type {string}
   * @memberof AddSignatureCommand
   */
  annotation?: string | null
  /**
   *
   * @type {ResponsibleType}
   * @memberof AddSignatureCommand
   */
  responsableType?: ResponsibleType
  /**
   *
   * @type {string}
   * @memberof AddSignatureCommand
   */
  responsibleName?: string | null
  /**
   *
   * @type {string}
   * @memberof AddSignatureCommand
   */
  designation?: string | null
  /**
   *
   * @type {string}
   * @memberof AddSignatureCommand
   */
  remarks?: string | null
  /**
   *
   * @type {string}
   * @memberof AddSignatureCommand
   */
  date?: string
  /**
   *
   * @type {boolean}
   * @memberof AddSignatureCommand
   */
  principal?: boolean
  /**
   *
   * @type {number}
   * @memberof AddSignatureCommand
   */
  reportId?: number | null
  /**
   *
   * @type {number}
   * @memberof AddSignatureCommand
   */
  reportConfigurationId?: number | null
  /**
   *
   * @type {number}
   * @memberof AddSignatureCommand
   */
  order?: number
  /**
   *
   * @type {string}
   * @memberof AddSignatureCommand
   */
  signature?: string | null
}
/**
 *
 * @export
 * @interface Address
 */
export interface Address {
  /**
   *
   * @type {number}
   * @memberof Address
   */
  id?: number
  /**
   *
   * @type {Array<object>}
   * @memberof Address
   */
  domainEvents?: Array<object> | null
  /**
   *
   * @type {string}
   * @memberof Address
   */
  addressLine?: string | null
  /**
   *
   * @type {string}
   * @memberof Address
   */
  addressLine2?: string | null
  /**
   *
   * @type {string}
   * @memberof Address
   */
  unit?: string | null
  /**
   *
   * @type {string}
   * @memberof Address
   */
  country?: string | null
  /**
   *
   * @type {string}
   * @memberof Address
   */
  postalCode?: string | null
  /**
   *
   * @type {number}
   * @memberof Address
   */
  licenseId?: number | null
  /**
   *
   * @type {EMALicense}
   * @memberof Address
   */
  license?: EMALicense
}
/**
 *
 * @export
 * @interface AddressDto
 */
export interface AddressDto {
  /**
   *
   * @type {number}
   * @memberof AddressDto
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof AddressDto
   */
  addressLine?: string | null
  /**
   *
   * @type {string}
   * @memberof AddressDto
   */
  addressLine2?: string | null
  /**
   *
   * @type {string}
   * @memberof AddressDto
   */
  unit?: string | null
  /**
   *
   * @type {string}
   * @memberof AddressDto
   */
  country?: string | null
  /**
   *
   * @type {string}
   * @memberof AddressDto
   */
  postalCode?: string | null
  /**
   *
   * @type {number}
   * @memberof AddressDto
   */
  licenseId?: number | null
  /**
   *
   * @type {string}
   * @memberof AddressDto
   */
  number?: string | null
  /**
   *
   * @type {string}
   * @memberof AddressDto
   */
  name?: string | null
  /**
   *
   * @type {number}
   * @memberof AddressDto
   */
  amp?: number
  /**
   *
   * @type {number}
   * @memberof AddressDto
   */
  volt?: number
  /**
   *
   * @type {number}
   * @memberof AddressDto
   */
  kva?: number
  /**
   *
   * @type {DateTimeRange}
   * @memberof AddressDto
   */
  validity?: DateTimeRange
  /**
   *
   * @type {string}
   * @memberof AddressDto
   */
  formatedAddress?: string | null
}
/**
 *
 * @export
 * @interface CSTemplate
 */
export interface CSTemplate {
  /**
   *
   * @type {number}
   * @memberof CSTemplate
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof CSTemplate
   */
  project?: string | null
  /**
   *
   * @type {string}
   * @memberof CSTemplate
   */
  location?: string | null
  /**
   *
   * @type {boolean}
   * @memberof CSTemplate
   */
  isTemplate?: boolean
  /**
   *
   * @type {string}
   * @memberof CSTemplate
   */
  dateCreated?: string | null
  /**
   *
   * @type {number}
   * @memberof CSTemplate
   */
  materialMarkup?: number
  /**
   *
   * @type {number}
   * @memberof CSTemplate
   */
  labourDailyRate?: number
  /**
   *
   * @type {number}
   * @memberof CSTemplate
   */
  labourNightMultiplier?: number
  /**
   *
   * @type {number}
   * @memberof CSTemplate
   */
  finalMarkup?: number
  /**
   *
   * @type {Array<Section>}
   * @memberof CSTemplate
   */
  sections?: Array<Section> | null
  /**
   *
   * @type {string}
   * @memberof CSTemplate
   */
  lastUpdate?: string | null
  /**
   *
   * @type {boolean}
   * @memberof CSTemplate
   */
  updated?: boolean
  /**
   *
   * @type {string}
   * @memberof CSTemplate
   */
  lastEdit?: string
  /**
   *
   * @type {string}
   * @memberof CSTemplate
   */
  lastEditUser?: string | null
}
/**
 *
 * @export
 * @interface ChangePasswordDto
 */
export interface ChangePasswordDto {
  /**
   *
   * @type {string}
   * @memberof ChangePasswordDto
   */
  userName?: string | null
  /**
   *
   * @type {string}
   * @memberof ChangePasswordDto
   */
  currentPassword?: string | null
  /**
   *
   * @type {string}
   * @memberof ChangePasswordDto
   */
  newPassword?: string | null
  /**
   *
   * @type {string}
   * @memberof ChangePasswordDto
   */
  newPasswordConfirmation?: string | null
}
/**
 *
 * @export
 * @enum {string}
 */
export enum CheckListDisplay {
  Numbered = 0,
  Inline = 1,
}

/**
 *
 * @export
 * @interface CheckListItemDTO
 */
export interface CheckListItemDTO {
  /**
   *
   * @type {number}
   * @memberof CheckListItemDTO
   */
  id?: number
  /**
   *
   * @type {number}
   * @memberof CheckListItemDTO
   */
  checkListId?: number
  /**
   *
   * @type {string}
   * @memberof CheckListItemDTO
   */
  text?: string | null
  /**
   *
   * @type {CheckValue}
   * @memberof CheckListItemDTO
   */
  checked?: CheckValue
  /**
   *
   * @type {boolean}
   * @memberof CheckListItemDTO
   */
  editable?: boolean
  /**
   *
   * @type {boolean}
   * @memberof CheckListItemDTO
   */
  required?: boolean
  /**
   *
   * @type {string}
   * @memberof CheckListItemDTO
   */
  remarks?: string | null
}
/**
 *
 * @export
 * @interface CheckListItemQueryResult
 */
export interface CheckListItemQueryResult {
  /**
   *
   * @type {number}
   * @memberof CheckListItemQueryResult
   */
  checkListId?: number
  /**
   *
   * @type {number}
   * @memberof CheckListItemQueryResult
   */
  checked?: number
  /**
   *
   * @type {boolean}
   * @memberof CheckListItemQueryResult
   */
  editable?: boolean
  /**
   *
   * @type {number}
   * @memberof CheckListItemQueryResult
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof CheckListItemQueryResult
   */
  remarks?: string | null
  /**
   *
   * @type {boolean}
   * @memberof CheckListItemQueryResult
   */
  required?: boolean
  /**
   *
   * @type {string}
   * @memberof CheckListItemQueryResult
   */
  text?: string | null
  /**
   *
   * @type {boolean}
   * @memberof CheckListItemQueryResult
   */
  touched?: boolean
}
/**
 *
 * @export
 * @interface CheckListPrintingMetadata
 */
export interface CheckListPrintingMetadata {
  /**
   *
   * @type {CheckListDisplay}
   * @memberof CheckListPrintingMetadata
   */
  display?: CheckListDisplay
}
/**
 *
 * @export
 * @interface CheckListQueryResult
 */
export interface CheckListQueryResult {
  /**
   *
   * @type {number}
   * @memberof CheckListQueryResult
   */
  id?: number
  /**
   *
   * @type {number}
   * @memberof CheckListQueryResult
   */
  reportId?: number
  /**
   *
   * @type {string}
   * @memberof CheckListQueryResult
   */
  text?: string | null
  /**
   *
   * @type {string}
   * @memberof CheckListQueryResult
   */
  annotation?: string | null
  /**
   *
   * @type {boolean}
   * @memberof CheckListQueryResult
   */
  checked?: boolean
  /**
   *
   * @type {Array<CheckListItemQueryResult>}
   * @memberof CheckListQueryResult
   */
  checks?: Array<CheckListItemQueryResult> | null
}
/**
 *
 * @export
 * @enum {string}
 */
export enum CheckValue {
  NotAcceptableFalse,
  Acceptable,
  NotApplicable,
  None,
}

/**
 *
 * @export
 * @interface CostSheet
 */
export interface CostSheet {
  /**
   *
   * @type {number}
   * @memberof CostSheet
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof CostSheet
   */
  project?: string | null
  /**
   *
   * @type {string}
   * @memberof CostSheet
   */
  location?: string | null
  /**
   *
   * @type {boolean}
   * @memberof CostSheet
   */
  isTemplate?: boolean
  /**
   *
   * @type {string}
   * @memberof CostSheet
   */
  dateCreated?: string | null
  /**
   *
   * @type {number}
   * @memberof CostSheet
   */
  materialMarkup?: number
  /**
   *
   * @type {number}
   * @memberof CostSheet
   */
  labourDailyRate?: number
  /**
   *
   * @type {number}
   * @memberof CostSheet
   */
  labourNightMultiplier?: number
  /**
   *
   * @type {number}
   * @memberof CostSheet
   */
  finalMarkup?: number
  /**
   *
   * @type {Array<Section>}
   * @memberof CostSheet
   */
  sections?: Array<Section> | null
  /**
   *
   * @type {string}
   * @memberof CostSheet
   */
  lastUpdate?: string | null
  /**
   *
   * @type {boolean}
   * @memberof CostSheet
   */
  updated?: boolean
  /**
   *
   * @type {string}
   * @memberof CostSheet
   */
  lastEdit?: string
  /**
   *
   * @type {string}
   * @memberof CostSheet
   */
  lastEditUser?: string | null
}
/**
 *
 * @export
 * @interface CreateReportCommand
 */
export interface CreateReportCommand {
  /**
   *
   * @type {number}
   * @memberof CreateReportCommand
   */
  configurationId?: number
  /**
   *
   * @type {ReportType}
   * @memberof CreateReportCommand
   */
  reportType?: ReportType
}
/**
 *
 * @export
 * @interface CurrentTable
 */
export interface CurrentTable {
  /**
   *
   * @type {number}
   * @memberof CurrentTable
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof CurrentTable
   */
  circuit?: string | null
  /**
   *
   * @type {string}
   * @memberof CurrentTable
   */
  startDate?: string | null
  /**
   *
   * @type {string}
   * @memberof CurrentTable
   */
  endDate?: string | null
  /**
   *
   * @type {string}
   * @memberof CurrentTable
   */
  currentData?: string | null
  /**
   *
   * @type {string}
   * @memberof CurrentTable
   */
  lastEdit?: string
  /**
   *
   * @type {string}
   * @memberof CurrentTable
   */
  lastEditUser?: string | null
}
/**
 *
 * @export
 * @interface DateTimeRange
 */
export interface DateTimeRange {
  /**
   *
   * @type {string}
   * @memberof DateTimeRange
   */
  start?: string
  /**
   *
   * @type {string}
   * @memberof DateTimeRange
   */
  end?: string
}
/**
 *
 * @export
 * @interface DynamicFieldMetadata
 */
export interface DynamicFieldMetadata {
  /**
   *
   * @type {string}
   * @memberof DynamicFieldMetadata
   */
  fieldName?: string | null
  /**
   *
   * @type {string}
   * @memberof DynamicFieldMetadata
   */
  sectionTitle?: string | null
  /**
   *
   * @type {string}
   * @memberof DynamicFieldMetadata
   */
  switchableSection?: string | null
  /**
   *
   * @type {string}
   * @memberof DynamicFieldMetadata
   */
  label?: string | null
  /**
   *
   * @type {string}
   * @memberof DynamicFieldMetadata
   */
  inputType?: string | null
  /**
   *
   * @type {string}
   * @memberof DynamicFieldMetadata
   */
  selectOptions?: string | null
  /**
   *
   * @type {string}
   * @memberof DynamicFieldMetadata
   */
  suffix?: string | null
  /**
   *
   * @type {string}
   * @memberof DynamicFieldMetadata
   */
  prefix?: string | null
  /**
   *
   * @type {number}
   * @memberof DynamicFieldMetadata
   */
  min?: number
  /**
   *
   * @type {number}
   * @memberof DynamicFieldMetadata
   */
  max?: number
  /**
   *
   * @type {number}
   * @memberof DynamicFieldMetadata
   */
  step?: number
  /**
   *
   * @type {number}
   * @memberof DynamicFieldMetadata
   */
  maxLength?: number
  /**
   *
   * @type {boolean}
   * @memberof DynamicFieldMetadata
   */
  enabled?: boolean
  /**
   *
   * @type {boolean}
   * @memberof DynamicFieldMetadata
   */
  rollerOnMobile?: boolean
  /**
   *
   * @type {number}
   * @memberof DynamicFieldMetadata
   */
  rollerDigits?: number
  /**
   *
   * @type {boolean}
   * @memberof DynamicFieldMetadata
   */
  visible?: boolean
  /**
   *
   * @type {any}
   * @memberof DynamicFieldMetadata
   */
  defaultValue?: any | null
  /**
   *
   * @type {number}
   * @memberof DynamicFieldMetadata
   */
  order?: number
}
/**
 *
 * @export
 * @interface DynamicFields
 */
export interface DynamicFields {
  /**
   *
   * @type {Array<DynamicFieldMetadata>}
   * @memberof DynamicFields
   */
  fieldsDefinitions?: Array<DynamicFieldMetadata> | null
}
/**
 *
 * @export
 * @interface EMALicense
 */
export interface EMALicense {
  /**
   *
   * @type {number}
   * @memberof EMALicense
   */
  id?: number
  /**
   *
   * @type {Array<object>}
   * @memberof EMALicense
   */
  domainEvents?: Array<object> | null
  /**
   *
   * @type {string}
   * @memberof EMALicense
   */
  number?: string | null
  /**
   *
   * @type {string}
   * @memberof EMALicense
   */
  name?: string | null
  /**
   *
   * @type {string}
   * @memberof EMALicense
   */
  personInCharge?: string | null
  /**
   *
   * @type {string}
   * @memberof EMALicense
   */
  contact?: string | null
  /**
   *
   * @type {string}
   * @memberof EMALicense
   */
  email?: string | null
  /**
   *
   * @type {number}
   * @memberof EMALicense
   */
  amp?: number
  /**
   *
   * @type {number}
   * @memberof EMALicense
   */
  volt?: number
  /**
   *
   * @type {number}
   * @memberof EMALicense
   */
  kva?: number
  /**
   *
   * @type {DateTimeRange}
   * @memberof EMALicense
   */
  validity?: DateTimeRange
}
/**
 *
 * @export
 * @interface EditNoteCommand
 */
export interface EditNoteCommand {
  /**
   *
   * @type {number}
   * @memberof EditNoteCommand
   */
  reportId?: number
  /**
   *
   * @type {number}
   * @memberof EditNoteCommand
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof EditNoteCommand
   */
  text?: string | null
  /**
   *
   * @type {boolean}
   * @memberof EditNoteCommand
   */
  checked?: boolean
}
/**
 *
 * @export
 * @interface EditPhotoRecordCommand
 */
export interface EditPhotoRecordCommand {
  /**
   *
   * @type {number}
   * @memberof EditPhotoRecordCommand
   */
  reportId?: number
  /**
   *
   * @type {number}
   * @memberof EditPhotoRecordCommand
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof EditPhotoRecordCommand
   */
  label?: string | null
}
/**
 *
 * @export
 * @interface EditPrintSectionCommand
 */
export interface EditPrintSectionCommand {
  /**
   *
   * @type {number}
   * @memberof EditPrintSectionCommand
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof EditPrintSectionCommand
   */
  code?: string | null
  /**
   *
   * @type {string}
   * @memberof EditPrintSectionCommand
   */
  description?: string | null
  /**
   *
   * @type {string}
   * @memberof EditPrintSectionCommand
   */
  content?: string | null
  /**
   *
   * @type {boolean}
   * @memberof EditPrintSectionCommand
   */
  isMainReport?: boolean
  /**
   *
   * @type {PrintSectionStatus}
   * @memberof EditPrintSectionCommand
   */
  status?: PrintSectionStatus
}
/**
 *
 * @export
 * @interface EditSignatureCommand
 */
export interface EditSignatureCommand {
  /**
   *
   * @type {number}
   * @memberof EditSignatureCommand
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof EditSignatureCommand
   */
  title?: string | null
  /**
   *
   * @type {string}
   * @memberof EditSignatureCommand
   */
  annotation?: string | null
  /**
   *
   * @type {ResponsibleType}
   * @memberof EditSignatureCommand
   */
  responsibleType?: ResponsibleType
  /**
   *
   * @type {string}
   * @memberof EditSignatureCommand
   */
  responsibleName?: string | null
  /**
   *
   * @type {string}
   * @memberof EditSignatureCommand
   */
  designation?: string | null
  /**
   *
   * @type {string}
   * @memberof EditSignatureCommand
   */
  remarks?: string | null
  /**
   *
   * @type {string}
   * @memberof EditSignatureCommand
   */
  date?: string
  /**
   *
   * @type {boolean}
   * @memberof EditSignatureCommand
   */
  principal?: boolean
  /**
   *
   * @type {string}
   * @memberof EditSignatureCommand
   */
  drawnSign?: string | null
  /**
   *
   * @type {number}
   * @memberof EditSignatureCommand
   */
  order?: number
}
/**
 *
 * @export
 * @interface FormDefinitionResponse
 */
export interface FormDefinitionResponse {
  /**
   *
   * @type {number}
   * @memberof FormDefinitionResponse
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof FormDefinitionResponse
   */
  name?: string | null
  /**
   *
   * @type {string}
   * @memberof FormDefinitionResponse
   */
  title?: string | null
  /**
   *
   * @type {string}
   * @memberof FormDefinitionResponse
   */
  icon?: string | null
  /**
   *
   * @type {DynamicFields}
   * @memberof FormDefinitionResponse
   */
  fields?: DynamicFields
  /**
   *
   * @type {any}
   * @memberof FormDefinitionResponse
   */
  defaultValues?: any | null
  /**
   *
   * @type {boolean}
   * @memberof FormDefinitionResponse
   */
  enabled?: boolean
  /**
   *
   * @type {number}
   * @memberof FormDefinitionResponse
   */
  order?: number
}
/**
 *
 * @export
 * @interface FormResult
 */
export interface FormResult {
  /**
   *
   * @type {number}
   * @memberof FormResult
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof FormResult
   */
  name?: string | null
  /**
   *
   * @type {string}
   * @memberof FormResult
   */
  title?: string | null
  /**
   *
   * @type {string}
   * @memberof FormResult
   */
  icon?: string | null
  /**
   *
   * @type {DynamicFields}
   * @memberof FormResult
   */
  fields?: DynamicFields
  /**
   *
   * @type {any}
   * @memberof FormResult
   */
  values?: any | null
  /**
   *
   * @type {boolean}
   * @memberof FormResult
   */
  enabled?: boolean
}
/**
 *
 * @export
 * @interface Item
 */
export interface Item {
  /**
   *
   * @type {string}
   * @memberof Item
   */
  itemNumber?: string | null
  /**
   *
   * @type {string}
   * @memberof Item
   */
  description?: string | null
  /**
   *
   * @type {number}
   * @memberof Item
   */
  materialMarkup?: number
  /**
   *
   * @type {number}
   * @memberof Item
   */
  noCables?: number
  /**
   *
   * @type {number}
   * @memberof Item
   */
  unitCost?: number
  /**
   *
   * @type {number}
   * @memberof Item
   */
  units?: number
  /**
   *
   * @type {number}
   * @memberof Item
   */
  labourCostUnit?: number
}
/**
 *
 * @export
 * @interface Job
 */
export interface Job {
  /**
   *
   * @type {number}
   * @memberof Job
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof Job
   */
  status?: string | null
  /**
   *
   * @type {string}
   * @memberof Job
   */
  value?: string | null
  /**
   *
   * @type {string}
   * @memberof Job
   */
  salesPerson?: string | null
  /**
   *
   * @type {number}
   * @memberof Job
   */
  priority?: number
  /**
   *
   * @type {string}
   * @memberof Job
   */
  scope?: string | null
  /**
   *
   * @type {string}
   * @memberof Job
   */
  tag?: string | null
  /**
   *
   * @type {string}
   * @memberof Job
   */
  comments?: string | null
  /**
   *
   * @type {string}
   * @memberof Job
   */
  teams?: string | null
  /**
   *
   * @type {string}
   * @memberof Job
   */
  teamCount?: string | null
  /**
   *
   * @type {string}
   * @memberof Job
   */
  duration?: string | null
  /**
   *
   * @type {string}
   * @memberof Job
   */
  shift?: string | null
  /**
   *
   * @type {boolean}
   * @memberof Job
   */
  updated?: boolean
  /**
   *
   * @type {string}
   * @memberof Job
   */
  lastUpdate?: string | null
  /**
   *
   * @type {string}
   * @memberof Job
   */
  lastEdit?: string
  /**
   *
   * @type {string}
   * @memberof Job
   */
  lastEditUser?: string | null
}
/**
 *
 * @export
 * @interface LicenseDTO
 */
export interface LicenseDTO {
  /**
   *
   * @type {number}
   * @memberof LicenseDTO
   */
  licenseId?: number
  /**
   *
   * @type {string}
   * @memberof LicenseDTO
   */
  number?: string | null
  /**
   *
   * @type {string}
   * @memberof LicenseDTO
   */
  name?: string | null
  /**
   *
   * @type {string}
   * @memberof LicenseDTO
   */
  personInCharge?: string | null
  /**
   *
   * @type {string}
   * @memberof LicenseDTO
   */
  contact?: string | null
  /**
   *
   * @type {string}
   * @memberof LicenseDTO
   */
  email?: string | null
  /**
   *
   * @type {number}
   * @memberof LicenseDTO
   */
  amp?: number
  /**
   *
   * @type {number}
   * @memberof LicenseDTO
   */
  volt?: number
  /**
   *
   * @type {number}
   * @memberof LicenseDTO
   */
  kva?: number
  /**
   *
   * @type {string}
   * @memberof LicenseDTO
   */
  validityStart?: string
  /**
   *
   * @type {string}
   * @memberof LicenseDTO
   */
  validityEnd?: string
}
/**
 *
 * @export
 * @interface LoginModel
 */
export interface LoginModel {
  /**
   *
   * @type {string}
   * @memberof LoginModel
   */
  username?: string | null
  /**
   *
   * @type {string}
   * @memberof LoginModel
   */
  password?: string | null
}
/**
 *
 * @export
 * @interface NewAddressDto
 */
export interface NewAddressDto {
  /**
   *
   * @type {number}
   * @memberof NewAddressDto
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof NewAddressDto
   */
  addressLine?: string | null
  /**
   *
   * @type {string}
   * @memberof NewAddressDto
   */
  addressLine2?: string | null
  /**
   *
   * @type {string}
   * @memberof NewAddressDto
   */
  unit?: string | null
  /**
   *
   * @type {string}
   * @memberof NewAddressDto
   */
  country?: string | null
  /**
   *
   * @type {string}
   * @memberof NewAddressDto
   */
  postalCode?: string | null
  /**
   *
   * @type {number}
   * @memberof NewAddressDto
   */
  licenseId?: number | null
}
/**
 *
 * @export
 * @interface NewFormDefinitionCommand
 */
export interface NewFormDefinitionCommand {
  /**
   *
   * @type {number}
   * @memberof NewFormDefinitionCommand
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof NewFormDefinitionCommand
   */
  name?: string | null
  /**
   *
   * @type {string}
   * @memberof NewFormDefinitionCommand
   */
  title?: string | null
  /**
   *
   * @type {string}
   * @memberof NewFormDefinitionCommand
   */
  icon?: string | null
  /**
   *
   * @type {DynamicFields}
   * @memberof NewFormDefinitionCommand
   */
  fields?: DynamicFields
  /**
   *
   * @type {any}
   * @memberof NewFormDefinitionCommand
   */
  defaultValues?: any | null
  /**
   *
   * @type {boolean}
   * @memberof NewFormDefinitionCommand
   */
  enabled?: boolean
  /**
   *
   * @type {number}
   * @memberof NewFormDefinitionCommand
   */
  order?: number
  /**
   *
   * @type {Array<number>}
   * @memberof NewFormDefinitionCommand
   */
  reports?: Array<number> | null
  /**
   *
   * @type {Array<number>}
   * @memberof NewFormDefinitionCommand
   */
  reportConfigurations?: Array<number> | null
}
/**
 *
 * @export
 * @interface NoteQueryResult
 */
export interface NoteQueryResult {
  /**
   *
   * @type {number}
   * @memberof NoteQueryResult
   */
  id?: number
  /**
   *
   * @type {number}
   * @memberof NoteQueryResult
   */
  reportId?: number
  /**
   *
   * @type {string}
   * @memberof NoteQueryResult
   */
  text?: string | null
  /**
   *
   * @type {boolean}
   * @memberof NoteQueryResult
   */
  checked?: boolean
  /**
   *
   * @type {boolean}
   * @memberof NoteQueryResult
   */
  needsCheck?: boolean
}
/**
 *
 * @export
 * @interface Options
 */
export interface Options {
  /**
   *
   * @type {number}
   * @memberof Options
   */
  id?: number
  /**
   *
   * @type {number}
   * @memberof Options
   */
  scheduleWeeks?: number
  /**
   *
   * @type {number}
   * @memberof Options
   */
  autosaveInterval?: number
  /**
   *
   * @type {string}
   * @memberof Options
   */
  lastUpdate?: string
  /**
   *
   * @type {string}
   * @memberof Options
   */
  lastEdit?: string
  /**
   *
   * @type {string}
   * @memberof Options
   */
  lastEditUser?: string | null
}
/**
 *
 * @export
 * @interface PrintSectionDto
 */
export interface PrintSectionDto {
  /**
   *
   * @type {number}
   * @memberof PrintSectionDto
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof PrintSectionDto
   */
  code?: string | null
  /**
   *
   * @type {string}
   * @memberof PrintSectionDto
   */
  description?: string | null
  /**
   *
   * @type {string}
   * @memberof PrintSectionDto
   */
  content?: string | null
  /**
   *
   * @type {boolean}
   * @memberof PrintSectionDto
   */
  isMainReport?: boolean
  /**
   *
   * @type {PrintSectionStatus}
   * @memberof PrintSectionDto
   */
  status?: PrintSectionStatus
}
/**
 *
 * @export
 * @enum {string}
 */
export enum PrintSectionStatus {
  Inactive = 0,
  Active = 1,
}

/**
 *
 * @export
 * @interface ProblemDetails
 */
export interface ProblemDetails {
  [key: string]: any | any

  /**
   *
   * @type {string}
   * @memberof ProblemDetails
   */
  type?: string | null
  /**
   *
   * @type {string}
   * @memberof ProblemDetails
   */
  title?: string | null
  /**
   *
   * @type {number}
   * @memberof ProblemDetails
   */
  status?: number | null
  /**
   *
   * @type {string}
   * @memberof ProblemDetails
   */
  detail?: string | null
  /**
   *
   * @type {string}
   * @memberof ProblemDetails
   */
  instance?: string | null
}
/**
 *
 * @export
 * @interface ReportConfigurationDto
 */
export interface ReportConfigurationDto {
  /**
   *
   * @type {number}
   * @memberof ReportConfigurationDto
   */
  id?: number
  /**
   *
   * @type {ReportType}
   * @memberof ReportConfigurationDto
   */
  type?: ReportType
  /**
   *
   * @type {string}
   * @memberof ReportConfigurationDto
   */
  title?: string | null
  /**
   *
   * @type {string}
   * @memberof ReportConfigurationDto
   */
  formName?: string | null
  /**
   *
   * @type {string}
   * @memberof ReportConfigurationDto
   */
  remarksLabelText?: string | null
  /**
   *
   * @type {Array<number>}
   * @memberof ReportConfigurationDto
   */
  checksDefinition?: Array<number> | null
  /**
   *
   * @type {Array<number>}
   * @memberof ReportConfigurationDto
   */
  signatureDefinitions?: Array<number> | null
  /**
   *
   * @type {Array<FormDefinitionResponse>}
   * @memberof ReportConfigurationDto
   */
  forms?: Array<FormDefinitionResponse> | null
  /**
   *
   * @type {CheckListPrintingMetadata}
   * @memberof ReportConfigurationDto
   */
  checkListMetadata?: CheckListPrintingMetadata
  /**
   *
   * @type {number}
   * @memberof ReportConfigurationDto
   */
  printSectionId?: number | null
  /**
   *
   * @type {string}
   * @memberof ReportConfigurationDto
   */
  templateName?: string | null
  /**
   *
   * @type {CheckListDisplay}
   * @memberof ReportConfigurationDto
   */
  display?: CheckListDisplay
}
/**
 *
 * @export
 * @interface ReportQueryResult
 */
export interface ReportQueryResult {
  /**
   *
   * @type {number}
   * @memberof ReportQueryResult
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof ReportQueryResult
   */
  name?: string | null
  /**
   *
   * @type {string}
   * @memberof ReportQueryResult
   */
  address?: string | null
  /**
   *
   * @type {string}
   * @memberof ReportQueryResult
   */
  date?: string
  /**
   *
   * @type {string}
   * @memberof ReportQueryResult
   */
  licenseNumber?: string | null
  /**
   *
   * @type {string}
   * @memberof ReportQueryResult
   */
  licenseName?: string | null
  /**
   *
   * @type {number}
   * @memberof ReportQueryResult
   */
  licenseKVA?: number | null
  /**
   *
   * @type {number}
   * @memberof ReportQueryResult
   */
  licenseVolt?: number | null
  /**
   *
   * @type {number}
   * @memberof ReportQueryResult
   */
  licenseAmp?: number | null
  /**
   *
   * @type {number}
   * @memberof ReportQueryResult
   */
  reportConfigurationId?: number
  /**
   *
   * @type {DateTimeRange}
   * @memberof ReportQueryResult
   */
  licenseValidity?: DateTimeRange
  /**
   *
   * @type {string}
   * @memberof ReportQueryResult
   */
  title?: string | null
  /**
   *
   * @type {string}
   * @memberof ReportQueryResult
   */
  formName?: string | null
  /**
   *
   * @type {string}
   * @memberof ReportQueryResult
   */
  remarksLabelText?: string | null
  /**
   *
   * @type {boolean}
   * @memberof ReportQueryResult
   */
  isClosed?: boolean
  /**
   *
   * @type {Array<FormResult>}
   * @memberof ReportQueryResult
   */
  forms?: Array<FormResult> | null
  /**
   *
   * @type {Array<SignatureQueryResult>}
   * @memberof ReportQueryResult
   */
  signatures?: Array<SignatureQueryResult> | null
  /**
   *
   * @type {Array<CheckListQueryResult>}
   * @memberof ReportQueryResult
   */
  checkLists?: Array<CheckListQueryResult> | null
  /**
   *
   * @type {Array<NoteQueryResult>}
   * @memberof ReportQueryResult
   */
  notes?: Array<NoteQueryResult> | null
}
/**
 *
 * @export
 * @enum {string}
 */
export enum ReportType {
  Inspection = 0,
}

/**
 *
 * @export
 * @enum {string}
 */
export enum ResponsibleType {
  Supervisor,
  Inspector,
  Witness,
  LEW,
  Other,
}

/**
 *
 * @export
 * @interface ResumenReportConfiguration
 */
export interface ResumenReportConfiguration {
  /**
   *
   * @type {number}
   * @memberof ResumenReportConfiguration
   */
  id?: number
  /**
   *
   * @type {number}
   * @memberof ResumenReportConfiguration
   */
  type?: number
  /**
   *
   * @type {string}
   * @memberof ResumenReportConfiguration
   */
  title?: string | null
  /**
   *
   * @type {string}
   * @memberof ResumenReportConfiguration
   */
  formName?: string | null
  /**
   *
   * @type {string}
   * @memberof ResumenReportConfiguration
   */
  remarksLabelText?: string | null
  /**
   *
   * @type {number}
   * @memberof ResumenReportConfiguration
   */
  definedCheckLists?: number
  /**
   *
   * @type {number}
   * @memberof ResumenReportConfiguration
   */
  definedSignatures?: number
  /**
   *
   * @type {number}
   * @memberof ResumenReportConfiguration
   */
  usedByReports?: number
  /**
   *
   * @type {boolean}
   * @memberof ResumenReportConfiguration
   */
  inactive?: boolean
  /**
   *
   * @type {string}
   * @memberof ResumenReportConfiguration
   */
  printSection?: string | null
}
/**
 *
 * @export
 * @interface SchedJob
 */
export interface SchedJob {
  /**
   *
   * @type {number}
   * @memberof SchedJob
   */
  id?: number
  /**
   *
   * @type {number}
   * @memberof SchedJob
   */
  team?: number
  /**
   *
   * @type {string}
   * @memberof SchedJob
   */
  date: string
  /**
   *
   * @type {string}
   * @memberof SchedJob
   */
  shift?: string | null
  /**
   *
   * @type {boolean}
   * @memberof SchedJob
   */
  splitShift?: boolean
  /**
   *
   * @type {string}
   * @memberof SchedJob
   */
  job1?: string | null
  /**
   *
   * @type {string}
   * @memberof SchedJob
   */
  job2?: string | null
  /**
   *
   * @type {string}
   * @memberof SchedJob
   */
  teamMembers?: string | null
  /**
   *
   * @type {boolean}
   * @memberof SchedJob
   */
  excludeSaturday?: boolean
  /**
   *
   * @type {boolean}
   * @memberof SchedJob
   */
  excludeSunday?: boolean
  /**
   *
   * @type {string}
   * @memberof SchedJob
   */
  lastUpdate?: string | null
  /**
   *
   * @type {boolean}
   * @memberof SchedJob
   */
  updated?: boolean
  /**
   *
   * @type {string}
   * @memberof SchedJob
   */
  lastEdit?: string
  /**
   *
   * @type {string}
   * @memberof SchedJob
   */
  lastEditUser?: string | null
}
/**
 *
 * @export
 * @interface ScheduleData
 */
export interface ScheduleData {
  /**
   *
   * @type {string}
   * @memberof ScheduleData
   */
  lastUpdate?: string | null
  /**
   *
   * @type {Array<Job>}
   * @memberof ScheduleData
   */
  jobs?: Array<Job> | null
  /**
   *
   * @type {Array<SchedJob>}
   * @memberof ScheduleData
   */
  schedJobs?: Array<SchedJob> | null
  /**
   *
   * @type {Array<Team>}
   * @memberof ScheduleData
   */
  teams?: Array<Team> | null
  /**
   *
   * @type {Options}
   * @memberof ScheduleData
   */
  options?: Options
  /**
   *
   * @type {string}
   * @memberof ScheduleData
   */
  apiVersion?: string | null
}
/**
 *
 * @export
 * @interface Section
 */
export interface Section {
  /**
   *
   * @type {string}
   * @memberof Section
   */
  secNumber?: string | null
  /**
   *
   * @type {string}
   * @memberof Section
   */
  subSection?: string | null
  /**
   *
   * @type {string}
   * @memberof Section
   */
  description?: string | null
  /**
   *
   * @type {Array<Item>}
   * @memberof Section
   */
  items?: Array<Item> | null
  /**
   *
   * @type {number}
   * @memberof Section
   */
  materialMarkup?: number
  /**
   *
   * @type {number}
   * @memberof Section
   */
  finalMarkup?: number
}
/**
 *
 * @export
 * @interface SignatureDto
 */
export interface SignatureDto {
  /**
   *
   * @type {number}
   * @memberof SignatureDto
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof SignatureDto
   */
  title?: string | null
  /**
   *
   * @type {string}
   * @memberof SignatureDto
   */
  annotation?: string | null
  /**
   *
   * @type {ResponsibleType}
   * @memberof SignatureDto
   */
  responsableType?: ResponsibleType
  /**
   *
   * @type {string}
   * @memberof SignatureDto
   */
  responsableName?: string | null
  /**
   *
   * @type {string}
   * @memberof SignatureDto
   */
  designation?: string | null
  /**
   *
   * @type {string}
   * @memberof SignatureDto
   */
  remarks?: string | null
  /**
   *
   * @type {string}
   * @memberof SignatureDto
   */
  date?: string
  /**
   *
   * @type {boolean}
   * @memberof SignatureDto
   */
  principal?: boolean
  /**
   *
   * @type {number}
   * @memberof SignatureDto
   */
  reportId?: number | null
  /**
   *
   * @type {number}
   * @memberof SignatureDto
   */
  reportConfigurationId?: number | null
  /**
   *
   * @type {number}
   * @memberof SignatureDto
   */
  order?: number
}
/**
 *
 * @export
 * @interface SignatureQueryResult
 */
export interface SignatureQueryResult {
  /**
   *
   * @type {number}
   * @memberof SignatureQueryResult
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof SignatureQueryResult
   */
  date?: string
  /**
   *
   * @type {string}
   * @memberof SignatureQueryResult
   */
  annotation?: string | null
  /**
   *
   * @type {string}
   * @memberof SignatureQueryResult
   */
  designation?: string | null
  /**
   *
   * @type {string}
   * @memberof SignatureQueryResult
   */
  drawnSign?: string | null
  /**
   *
   * @type {boolean}
   * @memberof SignatureQueryResult
   */
  principal?: boolean
  /**
   *
   * @type {string}
   * @memberof SignatureQueryResult
   */
  remarks?: string | null
  /**
   *
   * @type {number}
   * @memberof SignatureQueryResult
   */
  responsibleType?: number | null
  /**
   *
   * @type {string}
   * @memberof SignatureQueryResult
   */
  responsibleTypeName?: string | null
  /**
   *
   * @type {string}
   * @memberof SignatureQueryResult
   */
  responsibleName?: string | null
  /**
   *
   * @type {string}
   * @memberof SignatureQueryResult
   */
  title?: string | null
  /**
   *
   * @type {number}
   * @memberof SignatureQueryResult
   */
  order?: number
  /**
   *
   * @type {boolean}
   * @memberof SignatureQueryResult
   */
  viewSign?: boolean
}
/**
 *
 * @export
 * @interface Team
 */
export interface Team {
  /**
   *
   * @type {number}
   * @memberof Team
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof Team
   */
  vehicle?: string | null
  /**
   *
   * @type {string}
   * @memberof Team
   */
  foreman?: string | null
  /**
   *
   * @type {number}
   * @memberof Team
   */
  position?: number
  /**
   *
   * @type {boolean}
   * @memberof Team
   */
  updated?: boolean
  /**
   *
   * @type {string}
   * @memberof Team
   */
  lastUpdate?: string | null
  /**
   *
   * @type {string}
   * @memberof Team
   */
  teamMembers?: string | null
  /**
   *
   * @type {string}
   * @memberof Team
   */
  lastEdit?: string
  /**
   *
   * @type {string}
   * @memberof Team
   */
  lastEditUser?: string | null
}
/**
 *
 * @export
 * @interface UpdateCheckListCommand
 */
export interface UpdateCheckListCommand {
  /**
   *
   * @type {number}
   * @memberof UpdateCheckListCommand
   */
  idCheckList?: number
  /**
   *
   * @type {string}
   * @memberof UpdateCheckListCommand
   */
  text?: string | null
  /**
   *
   * @type {string}
   * @memberof UpdateCheckListCommand
   */
  annotation?: string | null
  /**
   *
   * @type {boolean}
   * @memberof UpdateCheckListCommand
   */
  isConfiguration?: boolean
}
/**
 *
 * @export
 * @interface UpdateCheckListItemCommand
 */
export interface UpdateCheckListItemCommand {
  /**
   *
   * @type {number}
   * @memberof UpdateCheckListItemCommand
   */
  id?: number
  /**
   *
   * @type {number}
   * @memberof UpdateCheckListItemCommand
   */
  checkListId?: number
  /**
   *
   * @type {string}
   * @memberof UpdateCheckListItemCommand
   */
  text?: string | null
  /**
   *
   * @type {CheckValue}
   * @memberof UpdateCheckListItemCommand
   */
  checked?: CheckValue
  /**
   *
   * @type {boolean}
   * @memberof UpdateCheckListItemCommand
   */
  editable?: boolean
  /**
   *
   * @type {boolean}
   * @memberof UpdateCheckListItemCommand
   */
  required?: boolean
  /**
   *
   * @type {string}
   * @memberof UpdateCheckListItemCommand
   */
  remarks?: string | null
}
/**
 *
 * @export
 * @interface UpdateReportCommand
 */
export interface UpdateReportCommand {
  /**
   *
   * @type {number}
   * @memberof UpdateReportCommand
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof UpdateReportCommand
   */
  name?: string | null
  /**
   *
   * @type {string}
   * @memberof UpdateReportCommand
   */
  address?: string | null
  /**
   *
   * @type {string}
   * @memberof UpdateReportCommand
   */
  licenseNumber?: string | null
  /**
   *
   * @type {string}
   * @memberof UpdateReportCommand
   */
  date?: string
  /**
   *
   * @type {boolean}
   * @memberof UpdateReportCommand
   */
  isClosed?: boolean
}
/**
 *
 * @export
 * @interface UpdateReportConfigurationCommand
 */
export interface UpdateReportConfigurationCommand {
  /**
   *
   * @type {number}
   * @memberof UpdateReportConfigurationCommand
   */
  id?: number
  /**
   *
   * @type {ReportType}
   * @memberof UpdateReportConfigurationCommand
   */
  type?: ReportType
  /**
   *
   * @type {string}
   * @memberof UpdateReportConfigurationCommand
   */
  title?: string | null
  /**
   *
   * @type {string}
   * @memberof UpdateReportConfigurationCommand
   */
  formName?: string | null
  /**
   *
   * @type {string}
   * @memberof UpdateReportConfigurationCommand
   */
  remarksLabelText?: string | null
  /**
   *
   * @type {Array<number>}
   * @memberof UpdateReportConfigurationCommand
   */
  checksDefinition?: Array<number> | null
  /**
   *
   * @type {Array<number>}
   * @memberof UpdateReportConfigurationCommand
   */
  signatureDefinitions?: Array<number> | null
  /**
   *
   * @type {number}
   * @memberof UpdateReportConfigurationCommand
   */
  printSectionId?: number
  /**
   *
   * @type {CheckListDisplay}
   * @memberof UpdateReportConfigurationCommand
   */
  display?: CheckListDisplay
  /**
   *
   * @type {string}
   * @memberof UpdateReportConfigurationCommand
   */
  templateName?: string | null
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  userName?: string | null
  /**
   *
   * @type {string}
   * @memberof User
   */
  name?: string | null
  /**
   *
   * @type {string}
   * @memberof User
   */
  lastName?: string | null
  /**
   *
   * @type {string}
   * @memberof User
   */
  password?: string | null
  /**
   *
   * @type {number}
   * @memberof User
   */
  lastEditedReport?: number | null
  /**
   *
   * @type {boolean}
   * @memberof User
   */
  isAdmin?: boolean
}
/**
 *
 * @export
 * @interface UserDto
 */
export interface UserDto {
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  userName?: string | null
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  name?: string | null
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  lastName?: string | null
  /**
   *
   * @type {number}
   * @memberof UserDto
   */
  lastEditedReport?: number | null
  /**
   *
   * @type {boolean}
   * @memberof UserDto
   */
  isAdmin?: boolean
}

/**
 * AddressesApi - axios parameter creator
 * @export
 */
export const AddressesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {NewAddressDto} [newAddressDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addAddress: async (
      newAddressDto?: NewAddressDto,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/Addresses`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        newAddressDto,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiAddressesIdGet: async (
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiAddressesIdGet', 'id', id)
      const localVarPath = `/api/Addresses/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAddress: async (
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteAddress', 'id', id)
      const localVarPath = `/api/Addresses/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddresses: async (
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/Addresses`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {NewAddressDto} [newAddressDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAddress: async (
      id: number,
      newAddressDto?: NewAddressDto,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateAddress', 'id', id)
      const localVarPath = `/api/Addresses/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        newAddressDto,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AddressesApi - functional programming interface
 * @export
 */
export const AddressesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AddressesApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {NewAddressDto} [newAddressDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addAddress(
      newAddressDto?: NewAddressDto,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addAddress(
        newAddressDto,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiAddressesIdGet(
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiAddressesIdGet(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAddress(
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAddress(
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAddresses(
      filter?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<AddressDto>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAddresses(
        filter,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {NewAddressDto} [newAddressDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateAddress(
      id: number,
      newAddressDto?: NewAddressDto,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateAddress(
        id,
        newAddressDto,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * AddressesApi - factory interface
 * @export
 */
export const AddressesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AddressesApiFp(configuration)
  return {
    /**
     *
     * @param {NewAddressDto} [newAddressDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addAddress(
      newAddressDto?: NewAddressDto,
      options?: any
    ): AxiosPromise<Address> {
      return localVarFp
        .addAddress(newAddressDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiAddressesIdGet(id: number, options?: any): AxiosPromise<AddressDto> {
      return localVarFp
        .apiAddressesIdGet(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAddress(id: number, options?: any): AxiosPromise<AddressDto> {
      return localVarFp
        .deleteAddress(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAddresses(
      filter?: string,
      options?: any
    ): AxiosPromise<Array<AddressDto>> {
      return localVarFp
        .getAddresses(filter, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {NewAddressDto} [newAddressDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAddress(
      id: number,
      newAddressDto?: NewAddressDto,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .updateAddress(id, newAddressDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
export class AddressesApi extends BaseAPI {
  /**
   *
   * @param {NewAddressDto} [newAddressDto]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  public addAddress(newAddressDto?: NewAddressDto, options?: any) {
    return AddressesApiFp(this.configuration)
      .addAddress(newAddressDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  public apiAddressesIdGet(id: number, options?: any) {
    return AddressesApiFp(this.configuration)
      .apiAddressesIdGet(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  public deleteAddress(id: number, options?: any) {
    return AddressesApiFp(this.configuration)
      .deleteAddress(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} [filter]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  public getAddresses(filter?: string, options?: any) {
    return AddressesApiFp(this.configuration)
      .getAddresses(filter, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {NewAddressDto} [newAddressDto]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AddressesApi
   */
  public updateAddress(
    id: number,
    newAddressDto?: NewAddressDto,
    options?: any
  ) {
    return AddressesApiFp(this.configuration)
      .updateAddress(id, newAddressDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Generates a JWT token for use in api call
     * @param {LoginModel} [loginModel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login: async (
      loginModel?: LoginModel,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/Auth/token`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        loginModel,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Generates a JWT token for use in api call
     * @param {LoginModel} [loginModel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async login(
      loginModel?: LoginModel,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.login(
        loginModel,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AuthApiFp(configuration)
  return {
    /**
     *
     * @summary Generates a JWT token for use in api call
     * @param {LoginModel} [loginModel]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(loginModel?: LoginModel, options?: any): AxiosPromise<void> {
      return localVarFp
        .login(loginModel, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   *
   * @summary Generates a JWT token for use in api call
   * @param {LoginModel} [loginModel]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public login(loginModel?: LoginModel, options?: any) {
    return AuthApiFp(this.configuration)
      .login(loginModel, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * CheckListsApi - axios parameter creator
 * @export
 */
export const CheckListsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {number} id
     * @param {AddCheckListItemCommand} [addCheckListItemCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addItemToChecklist: async (
      id: number,
      addCheckListItemCommand?: AddCheckListItemCommand,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('addItemToChecklist', 'id', id)
      const localVarPath = `/api/CheckLists/{id}/items`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        addCheckListItemCommand,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {AddCheckListCommand} [addCheckListCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCheckList: async (
      addCheckListCommand?: AddCheckListCommand,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/CheckLists`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        addCheckListCommand,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteChecklist: async (
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteChecklist', 'id', id)
      const localVarPath = `/api/CheckLists/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {number} idItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteChecklistItem: async (
      id: number,
      idItem: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteChecklistItem', 'id', id)
      // verify required parameter 'idItem' is not null or undefined
      assertParamExists('deleteChecklistItem', 'idItem', idItem)
      const localVarPath = `/api/CheckLists/{id}/items/{idItem}`
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'idItem'}}`, encodeURIComponent(String(idItem)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCheckListbyId: async (
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getCheckListbyId', 'id', id)
      const localVarPath = `/api/CheckLists/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} [filter]
     * @param {number} [reportConfigurationId]
     * @param {number} [reportId]
     * @param {boolean} [inConfigurationOnly]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChecklists: async (
      filter?: string,
      reportConfigurationId?: number,
      reportId?: number,
      inConfigurationOnly?: boolean,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/CheckLists`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      if (reportConfigurationId !== undefined) {
        localVarQueryParameter['reportConfigurationId'] = reportConfigurationId
      }

      if (reportId !== undefined) {
        localVarQueryParameter['reportId'] = reportId
      }

      if (inConfigurationOnly !== undefined) {
        localVarQueryParameter['inConfigurationOnly'] = inConfigurationOnly
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {UpdateCheckListCommand} [updateCheckListCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateChecklist: async (
      id: number,
      updateCheckListCommand?: UpdateCheckListCommand,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateChecklist', 'id', id)
      const localVarPath = `/api/CheckLists/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateCheckListCommand,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {number} idItem
     * @param {UpdateCheckListItemCommand} [updateCheckListItemCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateChecklistItem: async (
      id: number,
      idItem: number,
      updateCheckListItemCommand?: UpdateCheckListItemCommand,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateChecklistItem', 'id', id)
      // verify required parameter 'idItem' is not null or undefined
      assertParamExists('updateChecklistItem', 'idItem', idItem)
      const localVarPath = `/api/CheckLists/{id}/items/{idItem}`
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'idItem'}}`, encodeURIComponent(String(idItem)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateCheckListItemCommand,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * CheckListsApi - functional programming interface
 * @export
 */
export const CheckListsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CheckListsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {number} id
     * @param {AddCheckListItemCommand} [addCheckListItemCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addItemToChecklist(
      id: number,
      addCheckListItemCommand?: AddCheckListItemCommand,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addItemToChecklist(
          id,
          addCheckListItemCommand,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {AddCheckListCommand} [addCheckListCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createCheckList(
      addCheckListCommand?: AddCheckListCommand,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createCheckList(
        addCheckListCommand,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteChecklist(
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChecklist(
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {number} idItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteChecklistItem(
      id: number,
      idItem: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteChecklistItem(id, idItem, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCheckListbyId(
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCheckListbyId(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {string} [filter]
     * @param {number} [reportConfigurationId]
     * @param {number} [reportId]
     * @param {boolean} [inConfigurationOnly]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getChecklists(
      filter?: string,
      reportConfigurationId?: number,
      reportId?: number,
      inConfigurationOnly?: boolean,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getChecklists(
        filter,
        reportConfigurationId,
        reportId,
        inConfigurationOnly,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {UpdateCheckListCommand} [updateCheckListCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateChecklist(
      id: number,
      updateCheckListCommand?: UpdateCheckListCommand,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateChecklist(
        id,
        updateCheckListCommand,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {number} idItem
     * @param {UpdateCheckListItemCommand} [updateCheckListItemCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateChecklistItem(
      id: number,
      idItem: number,
      updateCheckListItemCommand?: UpdateCheckListItemCommand,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateChecklistItem(
          id,
          idItem,
          updateCheckListItemCommand,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * CheckListsApi - factory interface
 * @export
 */
export const CheckListsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CheckListsApiFp(configuration)
  return {
    /**
     *
     * @param {number} id
     * @param {AddCheckListItemCommand} [addCheckListItemCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addItemToChecklist(
      id: number,
      addCheckListItemCommand?: AddCheckListItemCommand,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .addItemToChecklist(id, addCheckListItemCommand, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {AddCheckListCommand} [addCheckListCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCheckList(
      addCheckListCommand?: AddCheckListCommand,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .createCheckList(addCheckListCommand, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteChecklist(id: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteChecklist(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {number} idItem
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteChecklistItem(
      id: number,
      idItem: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteChecklistItem(id, idItem, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCheckListbyId(id: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .getCheckListbyId(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} [filter]
     * @param {number} [reportConfigurationId]
     * @param {number} [reportId]
     * @param {boolean} [inConfigurationOnly]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChecklists(
      filter?: string,
      reportConfigurationId?: number,
      reportId?: number,
      inConfigurationOnly?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .getChecklists(
          filter,
          reportConfigurationId,
          reportId,
          inConfigurationOnly,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {UpdateCheckListCommand} [updateCheckListCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateChecklist(
      id: number,
      updateCheckListCommand?: UpdateCheckListCommand,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .updateChecklist(id, updateCheckListCommand, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {number} idItem
     * @param {UpdateCheckListItemCommand} [updateCheckListItemCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateChecklistItem(
      id: number,
      idItem: number,
      updateCheckListItemCommand?: UpdateCheckListItemCommand,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .updateChecklistItem(id, idItem, updateCheckListItemCommand, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * CheckListsApi - object-oriented interface
 * @export
 * @class CheckListsApi
 * @extends {BaseAPI}
 */
export class CheckListsApi extends BaseAPI {
  /**
   *
   * @param {number} id
   * @param {AddCheckListItemCommand} [addCheckListItemCommand]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CheckListsApi
   */
  public addItemToChecklist(
    id: number,
    addCheckListItemCommand?: AddCheckListItemCommand,
    options?: any
  ) {
    return CheckListsApiFp(this.configuration)
      .addItemToChecklist(id, addCheckListItemCommand, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {AddCheckListCommand} [addCheckListCommand]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CheckListsApi
   */
  public createCheckList(
    addCheckListCommand?: AddCheckListCommand,
    options?: any
  ) {
    return CheckListsApiFp(this.configuration)
      .createCheckList(addCheckListCommand, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CheckListsApi
   */
  public deleteChecklist(id: number, options?: any) {
    return CheckListsApiFp(this.configuration)
      .deleteChecklist(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {number} idItem
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CheckListsApi
   */
  public deleteChecklistItem(id: number, idItem: number, options?: any) {
    return CheckListsApiFp(this.configuration)
      .deleteChecklistItem(id, idItem, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CheckListsApi
   */
  public getCheckListbyId(id: number, options?: any) {
    return CheckListsApiFp(this.configuration)
      .getCheckListbyId(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} [filter]
   * @param {number} [reportConfigurationId]
   * @param {number} [reportId]
   * @param {boolean} [inConfigurationOnly]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CheckListsApi
   */
  public getChecklists(
    filter?: string,
    reportConfigurationId?: number,
    reportId?: number,
    inConfigurationOnly?: boolean,
    options?: any
  ) {
    return CheckListsApiFp(this.configuration)
      .getChecklists(
        filter,
        reportConfigurationId,
        reportId,
        inConfigurationOnly,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {UpdateCheckListCommand} [updateCheckListCommand]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CheckListsApi
   */
  public updateChecklist(
    id: number,
    updateCheckListCommand?: UpdateCheckListCommand,
    options?: any
  ) {
    return CheckListsApiFp(this.configuration)
      .updateChecklist(id, updateCheckListCommand, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {number} idItem
   * @param {UpdateCheckListItemCommand} [updateCheckListItemCommand]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CheckListsApi
   */
  public updateChecklistItem(
    id: number,
    idItem: number,
    updateCheckListItemCommand?: UpdateCheckListItemCommand,
    options?: any
  ) {
    return CheckListsApiFp(this.configuration)
      .updateChecklistItem(id, idItem, updateCheckListItemCommand, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * CostSheetApi - axios parameter creator
 * @export
 */
export const CostSheetApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCostSheetSheetGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/CostSheet/sheet`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCostSheetSheetIdDelete: async (
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiCostSheetSheetIdDelete', 'id', id)
      const localVarPath = `/api/CostSheet/sheet/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCostSheetSheetIdGet: async (
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiCostSheetSheetIdGet', 'id', id)
      const localVarPath = `/api/CostSheet/sheet/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCostSheetSheetPost: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/CostSheet/sheet`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCostSheetSheetPut: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/CostSheet/sheet`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCostSheetTemplateGet: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/CostSheet/template`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCostSheetTemplateIdDelete: async (
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiCostSheetTemplateIdDelete', 'id', id)
      const localVarPath = `/api/CostSheet/template/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCostSheetTemplateIdGet: async (
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiCostSheetTemplateIdGet', 'id', id)
      const localVarPath = `/api/CostSheet/template/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCostSheetTemplatePost: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/CostSheet/template`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCostSheetTemplatePut: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/CostSheet/template`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * CostSheetApi - functional programming interface
 * @export
 */
export const CostSheetApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CostSheetApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiCostSheetSheetGet(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiCostSheetSheetGet(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiCostSheetSheetIdDelete(
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiCostSheetSheetIdDelete(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiCostSheetSheetIdGet(
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CostSheet>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiCostSheetSheetIdGet(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiCostSheetSheetPost(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiCostSheetSheetPost(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiCostSheetSheetPut(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiCostSheetSheetPut(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiCostSheetTemplateGet(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiCostSheetTemplateGet(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiCostSheetTemplateIdDelete(
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiCostSheetTemplateIdDelete(
          id,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiCostSheetTemplateIdGet(
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CSTemplate>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiCostSheetTemplateIdGet(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiCostSheetTemplatePost(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiCostSheetTemplatePost(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiCostSheetTemplatePut(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiCostSheetTemplatePut(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * CostSheetApi - factory interface
 * @export
 */
export const CostSheetApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CostSheetApiFp(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCostSheetSheetGet(options?: any): AxiosPromise<void> {
      return localVarFp
        .apiCostSheetSheetGet(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCostSheetSheetIdDelete(id: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .apiCostSheetSheetIdDelete(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCostSheetSheetIdGet(id: number, options?: any): AxiosPromise<CostSheet> {
      return localVarFp
        .apiCostSheetSheetIdGet(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCostSheetSheetPost(options?: any): AxiosPromise<void> {
      return localVarFp
        .apiCostSheetSheetPost(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCostSheetSheetPut(options?: any): AxiosPromise<void> {
      return localVarFp
        .apiCostSheetSheetPut(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCostSheetTemplateGet(options?: any): AxiosPromise<void> {
      return localVarFp
        .apiCostSheetTemplateGet(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCostSheetTemplateIdDelete(
      id: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .apiCostSheetTemplateIdDelete(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCostSheetTemplateIdGet(
      id: number,
      options?: any
    ): AxiosPromise<CSTemplate> {
      return localVarFp
        .apiCostSheetTemplateIdGet(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCostSheetTemplatePost(options?: any): AxiosPromise<void> {
      return localVarFp
        .apiCostSheetTemplatePost(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCostSheetTemplatePut(options?: any): AxiosPromise<void> {
      return localVarFp
        .apiCostSheetTemplatePut(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * CostSheetApi - object-oriented interface
 * @export
 * @class CostSheetApi
 * @extends {BaseAPI}
 */
export class CostSheetApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CostSheetApi
   */
  public apiCostSheetSheetGet(options?: any) {
    return CostSheetApiFp(this.configuration)
      .apiCostSheetSheetGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CostSheetApi
   */
  public apiCostSheetSheetIdDelete(id: number, options?: any) {
    return CostSheetApiFp(this.configuration)
      .apiCostSheetSheetIdDelete(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CostSheetApi
   */
  public apiCostSheetSheetIdGet(id: number, options?: any) {
    return CostSheetApiFp(this.configuration)
      .apiCostSheetSheetIdGet(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CostSheetApi
   */
  public apiCostSheetSheetPost(options?: any) {
    return CostSheetApiFp(this.configuration)
      .apiCostSheetSheetPost(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CostSheetApi
   */
  public apiCostSheetSheetPut(options?: any) {
    return CostSheetApiFp(this.configuration)
      .apiCostSheetSheetPut(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CostSheetApi
   */
  public apiCostSheetTemplateGet(options?: any) {
    return CostSheetApiFp(this.configuration)
      .apiCostSheetTemplateGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CostSheetApi
   */
  public apiCostSheetTemplateIdDelete(id: number, options?: any) {
    return CostSheetApiFp(this.configuration)
      .apiCostSheetTemplateIdDelete(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CostSheetApi
   */
  public apiCostSheetTemplateIdGet(id: number, options?: any) {
    return CostSheetApiFp(this.configuration)
      .apiCostSheetTemplateIdGet(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CostSheetApi
   */
  public apiCostSheetTemplatePost(options?: any) {
    return CostSheetApiFp(this.configuration)
      .apiCostSheetTemplatePost(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CostSheetApi
   */
  public apiCostSheetTemplatePut(options?: any) {
    return CostSheetApiFp(this.configuration)
      .apiCostSheetTemplatePut(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * EMALicensesApi - axios parameter creator
 * @export
 */
export const EMALicensesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {LicenseDTO} [licenseDTO]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addLicense: async (
      licenseDTO?: LicenseDTO,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/EMALicenses`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        licenseDTO,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLicense: async (
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteLicense', 'id', id)
      const localVarPath = `/api/EMALicenses/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLicense: async (id: number, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getLicense', 'id', id)
      const localVarPath = `/api/EMALicenses/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLicenses: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/EMALicenses`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLicensesDashboard: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/EMALicenses/dashboard`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {LicenseDTO} [licenseDTO]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLicense: async (
      id: number,
      licenseDTO?: LicenseDTO,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateLicense', 'id', id)
      const localVarPath = `/api/EMALicenses/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        licenseDTO,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * EMALicensesApi - functional programming interface
 * @export
 */
export const EMALicensesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    EMALicensesApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {LicenseDTO} [licenseDTO]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addLicense(
      licenseDTO?: LicenseDTO,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EMALicense>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addLicense(
        licenseDTO,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteLicense(
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EMALicense>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLicense(
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLicense(
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LicenseDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLicense(
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLicenses(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLicenses(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLicensesDashboard(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<LicenseDTO>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLicensesDashboard(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {LicenseDTO} [licenseDTO]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateLicense(
      id: number,
      licenseDTO?: LicenseDTO,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateLicense(
        id,
        licenseDTO,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * EMALicensesApi - factory interface
 * @export
 */
export const EMALicensesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = EMALicensesApiFp(configuration)
  return {
    /**
     *
     * @param {LicenseDTO} [licenseDTO]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addLicense(
      licenseDTO?: LicenseDTO,
      options?: any
    ): AxiosPromise<EMALicense> {
      return localVarFp
        .addLicense(licenseDTO, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLicense(id: number, options?: any): AxiosPromise<EMALicense> {
      return localVarFp
        .deleteLicense(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLicense(id: number, options?: any): AxiosPromise<LicenseDTO> {
      return localVarFp
        .getLicense(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLicenses(options?: any): AxiosPromise<void> {
      return localVarFp
        .getLicenses(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLicensesDashboard(options?: any): AxiosPromise<Array<LicenseDTO>> {
      return localVarFp
        .getLicensesDashboard(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {LicenseDTO} [licenseDTO]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLicense(
      id: number,
      licenseDTO?: LicenseDTO,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .updateLicense(id, licenseDTO, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * EMALicensesApi - object-oriented interface
 * @export
 * @class EMALicensesApi
 * @extends {BaseAPI}
 */
export class EMALicensesApi extends BaseAPI {
  /**
   *
   * @param {LicenseDTO} [licenseDTO]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EMALicensesApi
   */
  public addLicense(licenseDTO?: LicenseDTO, options?: any) {
    return EMALicensesApiFp(this.configuration)
      .addLicense(licenseDTO, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EMALicensesApi
   */
  public deleteLicense(id: number, options?: any) {
    return EMALicensesApiFp(this.configuration)
      .deleteLicense(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EMALicensesApi
   */
  public getLicense(id: number, options?: any) {
    return EMALicensesApiFp(this.configuration)
      .getLicense(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EMALicensesApi
   */
  public getLicenses(options?: any) {
    return EMALicensesApiFp(this.configuration)
      .getLicenses(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EMALicensesApi
   */
  public getLicensesDashboard(options?: any) {
    return EMALicensesApiFp(this.configuration)
      .getLicensesDashboard(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {LicenseDTO} [licenseDTO]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EMALicensesApi
   */
  public updateLicense(id: number, licenseDTO?: LicenseDTO, options?: any) {
    return EMALicensesApiFp(this.configuration)
      .updateLicense(id, licenseDTO, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * EnergyReportApi - axios parameter creator
 * @export
 */
export const EnergyReportApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEnergyReportBackgroundGet: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/EnergyReport/background`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEnergyReportCategoryGet: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/EnergyReport/category`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEnergyReportCategoryPost: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/EnergyReport/category`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEnergyReportCurrentTablePost: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/EnergyReport/current-table`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} startDate
     * @param {string} endDate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEnergyReportCurrentTableStartDateEndDateGet: async (
      startDate: string,
      endDate: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'startDate' is not null or undefined
      assertParamExists(
        'apiEnergyReportCurrentTableStartDateEndDateGet',
        'startDate',
        startDate
      )
      // verify required parameter 'endDate' is not null or undefined
      assertParamExists(
        'apiEnergyReportCurrentTableStartDateEndDateGet',
        'endDate',
        endDate
      )
      const localVarPath =
        `/api/EnergyReport/current-table/{startDate}/{endDate}`
          .replace(`{${'startDate'}}`, encodeURIComponent(String(startDate)))
          .replace(`{${'endDate'}}`, encodeURIComponent(String(endDate)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * EnergyReportApi - functional programming interface
 * @export
 */
export const EnergyReportApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    EnergyReportApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiEnergyReportBackgroundGet(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiEnergyReportBackgroundGet(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiEnergyReportCategoryGet(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiEnergyReportCategoryGet(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiEnergyReportCategoryPost(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiEnergyReportCategoryPost(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiEnergyReportCurrentTablePost(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiEnergyReportCurrentTablePost(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {string} startDate
     * @param {string} endDate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiEnergyReportCurrentTableStartDateEndDateGet(
      startDate: string,
      endDate: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<CurrentTable>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiEnergyReportCurrentTableStartDateEndDateGet(
          startDate,
          endDate,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * EnergyReportApi - factory interface
 * @export
 */
export const EnergyReportApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = EnergyReportApiFp(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEnergyReportBackgroundGet(options?: any): AxiosPromise<void> {
      return localVarFp
        .apiEnergyReportBackgroundGet(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEnergyReportCategoryGet(options?: any): AxiosPromise<void> {
      return localVarFp
        .apiEnergyReportCategoryGet(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEnergyReportCategoryPost(options?: any): AxiosPromise<void> {
      return localVarFp
        .apiEnergyReportCategoryPost(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEnergyReportCurrentTablePost(options?: any): AxiosPromise<void> {
      return localVarFp
        .apiEnergyReportCurrentTablePost(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} startDate
     * @param {string} endDate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEnergyReportCurrentTableStartDateEndDateGet(
      startDate: string,
      endDate: string,
      options?: any
    ): AxiosPromise<Array<CurrentTable>> {
      return localVarFp
        .apiEnergyReportCurrentTableStartDateEndDateGet(
          startDate,
          endDate,
          options
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * EnergyReportApi - object-oriented interface
 * @export
 * @class EnergyReportApi
 * @extends {BaseAPI}
 */
export class EnergyReportApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnergyReportApi
   */
  public apiEnergyReportBackgroundGet(options?: any) {
    return EnergyReportApiFp(this.configuration)
      .apiEnergyReportBackgroundGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnergyReportApi
   */
  public apiEnergyReportCategoryGet(options?: any) {
    return EnergyReportApiFp(this.configuration)
      .apiEnergyReportCategoryGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnergyReportApi
   */
  public apiEnergyReportCategoryPost(options?: any) {
    return EnergyReportApiFp(this.configuration)
      .apiEnergyReportCategoryPost(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnergyReportApi
   */
  public apiEnergyReportCurrentTablePost(options?: any) {
    return EnergyReportApiFp(this.configuration)
      .apiEnergyReportCurrentTablePost(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} startDate
   * @param {string} endDate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnergyReportApi
   */
  public apiEnergyReportCurrentTableStartDateEndDateGet(
    startDate: string,
    endDate: string,
    options?: any
  ) {
    return EnergyReportApiFp(this.configuration)
      .apiEnergyReportCurrentTableStartDateEndDateGet(
        startDate,
        endDate,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * FormsApi - axios parameter creator
 * @export
 */
export const FormsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {NewFormDefinitionCommand} [newFormDefinitionCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFormDefinition: async (
      newFormDefinitionCommand?: NewFormDefinitionCommand,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/Forms`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        newFormDefinitionCommand,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFormDefinition: async (
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteFormDefinition', 'id', id)
      const localVarPath = `/api/Forms/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFormDefinition: async (
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getFormDefinition', 'id', id)
      const localVarPath = `/api/Forms/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFormsDefinitions: async (
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/Forms`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (filter !== undefined) {
        localVarQueryParameter['Filter'] = filter
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {NewFormDefinitionCommand} [newFormDefinitionCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFormDefinition: async (
      id: number,
      newFormDefinitionCommand?: NewFormDefinitionCommand,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateFormDefinition', 'id', id)
      const localVarPath = `/api/Forms/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        newFormDefinitionCommand,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * FormsApi - functional programming interface
 * @export
 */
export const FormsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FormsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {NewFormDefinitionCommand} [newFormDefinitionCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addFormDefinition(
      newFormDefinitionCommand?: NewFormDefinitionCommand,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<FormDefinitionResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addFormDefinition(
          newFormDefinitionCommand,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFormDefinition(
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteFormDefinition(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFormDefinition(
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFormDefinition(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFormsDefinitions(
      filter?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<FormDefinitionResponse>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getFormsDefinitions(filter, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {NewFormDefinitionCommand} [newFormDefinitionCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateFormDefinition(
      id: number,
      newFormDefinitionCommand?: NewFormDefinitionCommand,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateFormDefinition(
          id,
          newFormDefinitionCommand,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * FormsApi - factory interface
 * @export
 */
export const FormsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = FormsApiFp(configuration)
  return {
    /**
     *
     * @param {NewFormDefinitionCommand} [newFormDefinitionCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addFormDefinition(
      newFormDefinitionCommand?: NewFormDefinitionCommand,
      options?: any
    ): AxiosPromise<FormDefinitionResponse> {
      return localVarFp
        .addFormDefinition(newFormDefinitionCommand, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFormDefinition(id: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteFormDefinition(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFormDefinition(id: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .getFormDefinition(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFormsDefinitions(
      filter?: string,
      options?: any
    ): AxiosPromise<Array<FormDefinitionResponse>> {
      return localVarFp
        .getFormsDefinitions(filter, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {NewFormDefinitionCommand} [newFormDefinitionCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFormDefinition(
      id: number,
      newFormDefinitionCommand?: NewFormDefinitionCommand,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .updateFormDefinition(id, newFormDefinitionCommand, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * FormsApi - object-oriented interface
 * @export
 * @class FormsApi
 * @extends {BaseAPI}
 */
export class FormsApi extends BaseAPI {
  /**
   *
   * @param {NewFormDefinitionCommand} [newFormDefinitionCommand]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FormsApi
   */
  public addFormDefinition(
    newFormDefinitionCommand?: NewFormDefinitionCommand,
    options?: any
  ) {
    return FormsApiFp(this.configuration)
      .addFormDefinition(newFormDefinitionCommand, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FormsApi
   */
  public deleteFormDefinition(id: number, options?: any) {
    return FormsApiFp(this.configuration)
      .deleteFormDefinition(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FormsApi
   */
  public getFormDefinition(id: number, options?: any) {
    return FormsApiFp(this.configuration)
      .getFormDefinition(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} [filter]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FormsApi
   */
  public getFormsDefinitions(filter?: string, options?: any) {
    return FormsApiFp(this.configuration)
      .getFormsDefinitions(filter, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {NewFormDefinitionCommand} [newFormDefinitionCommand]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FormsApi
   */
  public updateFormDefinition(
    id: number,
    newFormDefinitionCommand?: NewFormDefinitionCommand,
    options?: any
  ) {
    return FormsApiFp(this.configuration)
      .updateFormDefinition(id, newFormDefinitionCommand, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * JobScheduleApi - axios parameter creator
 * @export
 */
export const JobScheduleApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiJobScheduleGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/JobSchedule`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {Array<Job>} [job]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiJobScheduleJobPut: async (
      job?: Array<Job>,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/JobSchedule/job`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        job,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {Options} [options]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiJobScheduleOptionsPut: async (
      _options?: Options,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/JobSchedule/options`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        options,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {ScheduleData} [scheduleData]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiJobSchedulePut: async (
      scheduleData?: ScheduleData,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/JobSchedule`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        scheduleData,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {Array<SchedJob>} [schedJob]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiJobScheduleSchedJobPut: async (
      schedJob?: Array<SchedJob>,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/JobSchedule/sched-job`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        schedJob,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {Array<Team>} [team]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiJobScheduleTeamPut: async (
      team?: Array<Team>,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/JobSchedule/team`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        team,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * JobScheduleApi - functional programming interface
 * @export
 */
export const JobScheduleApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    JobScheduleApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiJobScheduleGet(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleData>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiJobScheduleGet(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {Array<Job>} [job]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiJobScheduleJobPut(
      job?: Array<Job>,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiJobScheduleJobPut(job, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {Options} [options]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiJobScheduleOptionsPut(
      options?: Options,
      _options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiJobScheduleOptionsPut(
          options,
          _options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {ScheduleData} [scheduleData]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiJobSchedulePut(
      scheduleData?: ScheduleData,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleData>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiJobSchedulePut(scheduleData, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {Array<SchedJob>} [schedJob]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiJobScheduleSchedJobPut(
      schedJob?: Array<SchedJob>,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiJobScheduleSchedJobPut(
          schedJob,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {Array<Team>} [team]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiJobScheduleTeamPut(
      team?: Array<Team>,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiJobScheduleTeamPut(team, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * JobScheduleApi - factory interface
 * @export
 */
export const JobScheduleApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = JobScheduleApiFp(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiJobScheduleGet(options?: any): AxiosPromise<ScheduleData> {
      return localVarFp
        .apiJobScheduleGet(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {Array<Job>} [job]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiJobScheduleJobPut(job?: Array<Job>, options?: any): AxiosPromise<void> {
      return localVarFp
        .apiJobScheduleJobPut(job, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {Options} [options]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiJobScheduleOptionsPut(
      options?: Options,
      _options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .apiJobScheduleOptionsPut(options, _options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {ScheduleData} [scheduleData]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiJobSchedulePut(
      scheduleData?: ScheduleData,
      options?: any
    ): AxiosPromise<ScheduleData> {
      return localVarFp
        .apiJobSchedulePut(scheduleData, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {Array<SchedJob>} [schedJob]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiJobScheduleSchedJobPut(
      schedJob?: Array<SchedJob>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .apiJobScheduleSchedJobPut(schedJob, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {Array<Team>} [team]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiJobScheduleTeamPut(
      team?: Array<Team>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .apiJobScheduleTeamPut(team, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * JobScheduleApi - object-oriented interface
 * @export
 * @class JobScheduleApi
 * @extends {BaseAPI}
 */
export class JobScheduleApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof JobScheduleApi
   */
  public apiJobScheduleGet(options?: any) {
    return JobScheduleApiFp(this.configuration)
      .apiJobScheduleGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {Array<Job>} [job]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof JobScheduleApi
   */
  public apiJobScheduleJobPut(job?: Array<Job>, options?: any) {
    return JobScheduleApiFp(this.configuration)
      .apiJobScheduleJobPut(job, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {Options} [options]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof JobScheduleApi
   */
  public apiJobScheduleOptionsPut(options?: Options, _options?: any) {
    return JobScheduleApiFp(this.configuration)
      .apiJobScheduleOptionsPut(options, _options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {ScheduleData} [scheduleData]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof JobScheduleApi
   */
  public apiJobSchedulePut(scheduleData?: ScheduleData, options?: any) {
    return JobScheduleApiFp(this.configuration)
      .apiJobSchedulePut(scheduleData, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {Array<SchedJob>} [schedJob]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof JobScheduleApi
   */
  public apiJobScheduleSchedJobPut(schedJob?: Array<SchedJob>, options?: any) {
    return JobScheduleApiFp(this.configuration)
      .apiJobScheduleSchedJobPut(schedJob, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {Array<Team>} [team]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof JobScheduleApi
   */
  public apiJobScheduleTeamPut(team?: Array<Team>, options?: any) {
    return JobScheduleApiFp(this.configuration)
      .apiJobScheduleTeamPut(team, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * PrintSectionApi - axios parameter creator
 * @export
 */
export const PrintSectionApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiPrintSectionGet: async (
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/PrintSection`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiPrintSectionIdDelete: async (
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiPrintSectionIdDelete', 'id', id)
      const localVarPath = `/api/PrintSection/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiPrintSectionIdGet: async (
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiPrintSectionIdGet', 'id', id)
      const localVarPath = `/api/PrintSection/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {EditPrintSectionCommand} [editPrintSectionCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiPrintSectionIdPut: async (
      id: number,
      editPrintSectionCommand?: EditPrintSectionCommand,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiPrintSectionIdPut', 'id', id)
      const localVarPath = `/api/PrintSection/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        editPrintSectionCommand,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {AddPrintSectionCommand} [addPrintSectionCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiPrintSectionPost: async (
      addPrintSectionCommand?: AddPrintSectionCommand,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/PrintSection`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        addPrintSectionCommand,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PrintSectionApi - functional programming interface
 * @export
 */
export const PrintSectionApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PrintSectionApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiPrintSectionGet(
      filter?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<PrintSectionDto>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiPrintSectionGet(filter, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiPrintSectionIdDelete(
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiPrintSectionIdDelete(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiPrintSectionIdGet(
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiPrintSectionIdGet(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {EditPrintSectionCommand} [editPrintSectionCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiPrintSectionIdPut(
      id: number,
      editPrintSectionCommand?: EditPrintSectionCommand,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiPrintSectionIdPut(
          id,
          editPrintSectionCommand,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {AddPrintSectionCommand} [addPrintSectionCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiPrintSectionPost(
      addPrintSectionCommand?: AddPrintSectionCommand,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiPrintSectionPost(
          addPrintSectionCommand,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * PrintSectionApi - factory interface
 * @export
 */
export const PrintSectionApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PrintSectionApiFp(configuration)
  return {
    /**
     *
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiPrintSectionGet(
      filter?: string,
      options?: any
    ): AxiosPromise<Array<PrintSectionDto>> {
      return localVarFp
        .apiPrintSectionGet(filter, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiPrintSectionIdDelete(id: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .apiPrintSectionIdDelete(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiPrintSectionIdGet(id: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .apiPrintSectionIdGet(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {EditPrintSectionCommand} [editPrintSectionCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiPrintSectionIdPut(
      id: number,
      editPrintSectionCommand?: EditPrintSectionCommand,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .apiPrintSectionIdPut(id, editPrintSectionCommand, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {AddPrintSectionCommand} [addPrintSectionCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiPrintSectionPost(
      addPrintSectionCommand?: AddPrintSectionCommand,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .apiPrintSectionPost(addPrintSectionCommand, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * PrintSectionApi - object-oriented interface
 * @export
 * @class PrintSectionApi
 * @extends {BaseAPI}
 */
export class PrintSectionApi extends BaseAPI {
  /**
   *
   * @param {string} [filter]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PrintSectionApi
   */
  public apiPrintSectionGet(filter?: string, options?: any) {
    return PrintSectionApiFp(this.configuration)
      .apiPrintSectionGet(filter, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PrintSectionApi
   */
  public apiPrintSectionIdDelete(id: number, options?: any) {
    return PrintSectionApiFp(this.configuration)
      .apiPrintSectionIdDelete(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PrintSectionApi
   */
  public apiPrintSectionIdGet(id: number, options?: any) {
    return PrintSectionApiFp(this.configuration)
      .apiPrintSectionIdGet(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {EditPrintSectionCommand} [editPrintSectionCommand]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PrintSectionApi
   */
  public apiPrintSectionIdPut(
    id: number,
    editPrintSectionCommand?: EditPrintSectionCommand,
    options?: any
  ) {
    return PrintSectionApiFp(this.configuration)
      .apiPrintSectionIdPut(id, editPrintSectionCommand, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {AddPrintSectionCommand} [addPrintSectionCommand]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PrintSectionApi
   */
  public apiPrintSectionPost(
    addPrintSectionCommand?: AddPrintSectionCommand,
    options?: any
  ) {
    return PrintSectionApiFp(this.configuration)
      .apiPrintSectionPost(addPrintSectionCommand, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ReportConfigurationApi - axios parameter creator
 * @export
 */
export const ReportConfigurationApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportConfigurationGet: async (
      filter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/ReportConfiguration`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportConfigurationIdDelete: async (
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiReportConfigurationIdDelete', 'id', id)
      const localVarPath = `/api/ReportConfiguration/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportConfigurationIdGet: async (
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiReportConfigurationIdGet', 'id', id)
      const localVarPath = `/api/ReportConfiguration/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {UpdateReportConfigurationCommand} [updateReportConfigurationCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportConfigurationIdPut: async (
      id: number,
      updateReportConfigurationCommand?: UpdateReportConfigurationCommand,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiReportConfigurationIdPut', 'id', id)
      const localVarPath = `/api/ReportConfiguration/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateReportConfigurationCommand,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {AddReportConfigurationCommand} [addReportConfigurationCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportConfigurationPost: async (
      addReportConfigurationCommand?: AddReportConfigurationCommand,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/ReportConfiguration`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        addReportConfigurationCommand,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ReportConfigurationApi - functional programming interface
 * @export
 */
export const ReportConfigurationApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    ReportConfigurationApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiReportConfigurationGet(
      filter?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ResumenReportConfiguration>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiReportConfigurationGet(
          filter,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiReportConfigurationIdDelete(
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiReportConfigurationIdDelete(
          id,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiReportConfigurationIdGet(
      id: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ReportConfigurationDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiReportConfigurationIdGet(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {UpdateReportConfigurationCommand} [updateReportConfigurationCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiReportConfigurationIdPut(
      id: number,
      updateReportConfigurationCommand?: UpdateReportConfigurationCommand,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiReportConfigurationIdPut(
          id,
          updateReportConfigurationCommand,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {AddReportConfigurationCommand} [addReportConfigurationCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiReportConfigurationPost(
      addReportConfigurationCommand?: AddReportConfigurationCommand,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiReportConfigurationPost(
          addReportConfigurationCommand,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * ReportConfigurationApi - factory interface
 * @export
 */
export const ReportConfigurationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ReportConfigurationApiFp(configuration)
  return {
    /**
     *
     * @param {string} [filter]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportConfigurationGet(
      filter?: string,
      options?: any
    ): AxiosPromise<Array<ResumenReportConfiguration>> {
      return localVarFp
        .apiReportConfigurationGet(filter, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportConfigurationIdDelete(
      id: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .apiReportConfigurationIdDelete(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportConfigurationIdGet(
      id: number,
      options?: any
    ): AxiosPromise<ReportConfigurationDto> {
      return localVarFp
        .apiReportConfigurationIdGet(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {UpdateReportConfigurationCommand} [updateReportConfigurationCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportConfigurationIdPut(
      id: number,
      updateReportConfigurationCommand?: UpdateReportConfigurationCommand,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .apiReportConfigurationIdPut(
          id,
          updateReportConfigurationCommand,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {AddReportConfigurationCommand} [addReportConfigurationCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportConfigurationPost(
      addReportConfigurationCommand?: AddReportConfigurationCommand,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .apiReportConfigurationPost(addReportConfigurationCommand, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ReportConfigurationApi - object-oriented interface
 * @export
 * @class ReportConfigurationApi
 * @extends {BaseAPI}
 */
export class ReportConfigurationApi extends BaseAPI {
  /**
   *
   * @param {string} [filter]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportConfigurationApi
   */
  public apiReportConfigurationGet(filter?: string, options?: any) {
    return ReportConfigurationApiFp(this.configuration)
      .apiReportConfigurationGet(filter, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportConfigurationApi
   */
  public apiReportConfigurationIdDelete(id: number, options?: any) {
    return ReportConfigurationApiFp(this.configuration)
      .apiReportConfigurationIdDelete(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportConfigurationApi
   */
  public apiReportConfigurationIdGet(id: number, options?: any) {
    return ReportConfigurationApiFp(this.configuration)
      .apiReportConfigurationIdGet(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {UpdateReportConfigurationCommand} [updateReportConfigurationCommand]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportConfigurationApi
   */
  public apiReportConfigurationIdPut(
    id: number,
    updateReportConfigurationCommand?: UpdateReportConfigurationCommand,
    options?: any
  ) {
    return ReportConfigurationApiFp(this.configuration)
      .apiReportConfigurationIdPut(
        id,
        updateReportConfigurationCommand,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {AddReportConfigurationCommand} [addReportConfigurationCommand]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportConfigurationApi
   */
  public apiReportConfigurationPost(
    addReportConfigurationCommand?: AddReportConfigurationCommand,
    options?: any
  ) {
    return ReportConfigurationApiFp(this.configuration)
      .apiReportConfigurationPost(addReportConfigurationCommand, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ReportsApi - axios parameter creator
 * @export
 */
export const ReportsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {number} id
     * @param {boolean} [printPhotos]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _export: async (
      id: number,
      printPhotos?: boolean,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('_export', 'id', id)
      const localVarPath = `/api/Reports/{id}/export`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (printPhotos !== undefined) {
        localVarQueryParameter['printPhotos'] = printPhotos
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} [filter]
     * @param {boolean} [closed]
     * @param {boolean} [myReports]
     * @param {string} [orderBy]
     * @param {boolean} [descending]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportsGet: async (
      filter?: string,
      closed?: boolean,
      myReports?: boolean,
      orderBy?: string,
      descending?: boolean,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/Reports`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      if (closed !== undefined) {
        localVarQueryParameter['closed'] = closed
      }

      if (myReports !== undefined) {
        localVarQueryParameter['myReports'] = myReports
      }

      if (orderBy !== undefined) {
        localVarQueryParameter['orderBy'] = orderBy
      }

      if (descending !== undefined) {
        localVarQueryParameter['descending'] = descending
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportsIdDelete: async (
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiReportsIdDelete', 'id', id)
      const localVarPath = `/api/Reports/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportsIdGet: async (
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiReportsIdGet', 'id', id)
      const localVarPath = `/api/Reports/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {number} idNote
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportsIdNoteIdNoteDelete: async (
      id: number,
      idNote: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiReportsIdNoteIdNoteDelete', 'id', id)
      // verify required parameter 'idNote' is not null or undefined
      assertParamExists('apiReportsIdNoteIdNoteDelete', 'idNote', idNote)
      const localVarPath = `/api/Reports/{id}/note/{idNote}`
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'idNote'}}`, encodeURIComponent(String(idNote)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {number} idNote
     * @param {EditNoteCommand} [editNoteCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportsIdNoteIdNotePut: async (
      id: number,
      idNote: number,
      editNoteCommand?: EditNoteCommand,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiReportsIdNoteIdNotePut', 'id', id)
      // verify required parameter 'idNote' is not null or undefined
      assertParamExists('apiReportsIdNoteIdNotePut', 'idNote', idNote)
      const localVarPath = `/api/Reports/{id}/note/{idNote}`
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'idNote'}}`, encodeURIComponent(String(idNote)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        editNoteCommand,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {AddNoteCommand} [addNoteCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportsIdNotePost: async (
      id: number,
      addNoteCommand?: AddNoteCommand,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiReportsIdNotePost', 'id', id)
      const localVarPath = `/api/Reports/{id}/note`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        addNoteCommand,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportsIdPhotorecordGet: async (
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiReportsIdPhotorecordGet', 'id', id)
      const localVarPath = `/api/Reports/{id}/photorecord`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {number} idPhoto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportsIdPhotorecordIdPhotoDelete: async (
      id: number,
      idPhoto: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiReportsIdPhotorecordIdPhotoDelete', 'id', id)
      // verify required parameter 'idPhoto' is not null or undefined
      assertParamExists(
        'apiReportsIdPhotorecordIdPhotoDelete',
        'idPhoto',
        idPhoto
      )
      const localVarPath = `/api/Reports/{id}/photorecord/{idPhoto}`
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'idPhoto'}}`, encodeURIComponent(String(idPhoto)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {number} idPhoto
     * @param {EditPhotoRecordCommand} [editPhotoRecordCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportsIdPhotorecordIdPhotoPut: async (
      id: number,
      idPhoto: number,
      editPhotoRecordCommand?: EditPhotoRecordCommand,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiReportsIdPhotorecordIdPhotoPut', 'id', id)
      // verify required parameter 'idPhoto' is not null or undefined
      assertParamExists('apiReportsIdPhotorecordIdPhotoPut', 'idPhoto', idPhoto)
      const localVarPath = `/api/Reports/{id}/photorecord/{idPhoto}`
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'idPhoto'}}`, encodeURIComponent(String(idPhoto)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        editPhotoRecordCommand,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {string} [label]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportsIdPhotorecordPost: async (
      id: number,
      label?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiReportsIdPhotorecordPost', 'id', id)
      const localVarPath = `/api/Reports/{id}/photorecord`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (label !== undefined && label !== null) {
        localVarHeaderParameter['label'] = String(label)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {UpdateReportCommand} [updateReportCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportsIdPut: async (
      id: string,
      updateReportCommand?: UpdateReportCommand,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiReportsIdPut', 'id', id)
      const localVarPath = `/api/Reports/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateReportCommand,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {CreateReportCommand} [createReportCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportsPost: async (
      createReportCommand?: CreateReportCommand,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/Reports`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createReportCommand,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} reportId
     * @param {number} checkListId
     * @param {number} [newValue]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkUpdateChecks: async (
      reportId: number,
      checkListId: number,
      newValue?: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'reportId' is not null or undefined
      assertParamExists('bulkUpdateChecks', 'reportId', reportId)
      // verify required parameter 'checkListId' is not null or undefined
      assertParamExists('bulkUpdateChecks', 'checkListId', checkListId)
      const localVarPath = `/api/Reports/{reportId}/checklists/{checkListId}`
        .replace(`{${'reportId'}}`, encodeURIComponent(String(reportId)))
        .replace(`{${'checkListId'}}`, encodeURIComponent(String(checkListId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (newValue !== undefined) {
        localVarQueryParameter['newValue'] = newValue
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} reportId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeReport: async (
      reportId: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'reportId' is not null or undefined
      assertParamExists('completeReport', 'reportId', reportId)
      const localVarPath = `/api/Reports/{reportId}/complete`.replace(
        `{${'reportId'}}`,
        encodeURIComponent(String(reportId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {number} idForm
     * @param {any} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateForm: async (
      id: number,
      idForm: number,
      body?: any,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateForm', 'id', id)
      // verify required parameter 'idForm' is not null or undefined
      assertParamExists('updateForm', 'idForm', idForm)
      const localVarPath = `/api/Reports/{id}/forms/{idForm}`
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'idForm'}}`, encodeURIComponent(String(idForm)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ReportsApi - functional programming interface
 * @export
 */
export const ReportsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ReportsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {number} id
     * @param {boolean} [printPhotos]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async _export(
      id: number,
      printPhotos?: boolean,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator._export(
        id,
        printPhotos,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {string} [filter]
     * @param {boolean} [closed]
     * @param {boolean} [myReports]
     * @param {string} [orderBy]
     * @param {boolean} [descending]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiReportsGet(
      filter?: string,
      closed?: boolean,
      myReports?: boolean,
      orderBy?: string,
      descending?: boolean,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiReportsGet(
        filter,
        closed,
        myReports,
        orderBy,
        descending,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiReportsIdDelete(
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiReportsIdDelete(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiReportsIdGet(
      id: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ReportQueryResult>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiReportsIdGet(
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {number} idNote
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiReportsIdNoteIdNoteDelete(
      id: number,
      idNote: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiReportsIdNoteIdNoteDelete(
          id,
          idNote,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {number} idNote
     * @param {EditNoteCommand} [editNoteCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiReportsIdNoteIdNotePut(
      id: number,
      idNote: number,
      editNoteCommand?: EditNoteCommand,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiReportsIdNoteIdNotePut(
          id,
          idNote,
          editNoteCommand,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {AddNoteCommand} [addNoteCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiReportsIdNotePost(
      id: number,
      addNoteCommand?: AddNoteCommand,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiReportsIdNotePost(
          id,
          addNoteCommand,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiReportsIdPhotorecordGet(
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiReportsIdPhotorecordGet(id, options)
      // console.log("BASE_PATH", BASE_PATH)
      // console.log("localVarAxiosArgs", localVarAxiosArgs)
      // console.log("globalAxios", globalAxios)
      // console.log("configuration", configuration)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {number} idPhoto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiReportsIdPhotorecordIdPhotoDelete(
      id: number,
      idPhoto: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiReportsIdPhotorecordIdPhotoDelete(
          id,
          idPhoto,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {number} idPhoto
     * @param {EditPhotoRecordCommand} [editPhotoRecordCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiReportsIdPhotorecordIdPhotoPut(
      id: number,
      idPhoto: number,
      editPhotoRecordCommand?: EditPhotoRecordCommand,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiReportsIdPhotorecordIdPhotoPut(
          id,
          idPhoto,
          editPhotoRecordCommand,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {string} [label]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiReportsIdPhotorecordPost(
      id: number,
      label?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiReportsIdPhotorecordPost(
          id,
          label,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {string} id
     * @param {UpdateReportCommand} [updateReportCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiReportsIdPut(
      id: string,
      updateReportCommand?: UpdateReportCommand,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiReportsIdPut(
        id,
        updateReportCommand,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {CreateReportCommand} [createReportCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiReportsPost(
      createReportCommand?: CreateReportCommand,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiReportsPost(
        createReportCommand,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} reportId
     * @param {number} checkListId
     * @param {number} [newValue]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkUpdateChecks(
      reportId: number,
      checkListId: number,
      newValue?: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.bulkUpdateChecks(
          reportId,
          checkListId,
          newValue,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} reportId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async completeReport(
      reportId: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.completeReport(
        reportId,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {number} idForm
     * @param {any} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateForm(
      id: number,
      idForm: number,
      body?: any,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateForm(
        id,
        idForm,
        body,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * ReportsApi - factory interface
 * @export
 */
export const ReportsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ReportsApiFp(configuration)
  return {
    /**
     *
     * @param {number} id
     * @param {boolean} [printPhotos]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _export(
      id: number,
      printPhotos?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        ._export(id, printPhotos, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} [filter]
     * @param {boolean} [closed]
     * @param {boolean} [myReports]
     * @param {string} [orderBy]
     * @param {boolean} [descending]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportsGet(
      filter?: string,
      closed?: boolean,
      myReports?: boolean,
      orderBy?: string,
      descending?: boolean,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .apiReportsGet(filter, closed, myReports, orderBy, descending, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportsIdDelete(id: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .apiReportsIdDelete(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportsIdGet(
      id: number,
      options?: any
    ): AxiosPromise<ReportQueryResult> {
      return localVarFp
        .apiReportsIdGet(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {number} idNote
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportsIdNoteIdNoteDelete(
      id: number,
      idNote: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .apiReportsIdNoteIdNoteDelete(id, idNote, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {number} idNote
     * @param {EditNoteCommand} [editNoteCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportsIdNoteIdNotePut(
      id: number,
      idNote: number,
      editNoteCommand?: EditNoteCommand,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .apiReportsIdNoteIdNotePut(id, idNote, editNoteCommand, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {AddNoteCommand} [addNoteCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportsIdNotePost(
      id: number,
      addNoteCommand?: AddNoteCommand,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .apiReportsIdNotePost(id, addNoteCommand, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportsIdPhotorecordGet(id: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .apiReportsIdPhotorecordGet(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {number} idPhoto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportsIdPhotorecordIdPhotoDelete(
      id: number,
      idPhoto: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .apiReportsIdPhotorecordIdPhotoDelete(id, idPhoto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {number} idPhoto
     * @param {EditPhotoRecordCommand} [editPhotoRecordCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportsIdPhotorecordIdPhotoPut(
      id: number,
      idPhoto: number,
      editPhotoRecordCommand?: EditPhotoRecordCommand,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .apiReportsIdPhotorecordIdPhotoPut(
          id,
          idPhoto,
          editPhotoRecordCommand,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {string} [label]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportsIdPhotorecordPost(
      id: number,
      label?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .apiReportsIdPhotorecordPost(id, label, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} id
     * @param {UpdateReportCommand} [updateReportCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportsIdPut(
      id: string,
      updateReportCommand?: UpdateReportCommand,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .apiReportsIdPut(id, updateReportCommand, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {CreateReportCommand} [createReportCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiReportsPost(
      createReportCommand?: CreateReportCommand,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .apiReportsPost(createReportCommand, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} reportId
     * @param {number} checkListId
     * @param {number} [newValue]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkUpdateChecks(
      reportId: number,
      checkListId: number,
      newValue?: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .bulkUpdateChecks(reportId, checkListId, newValue, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} reportId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeReport(reportId: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .completeReport(reportId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {number} idForm
     * @param {any} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateForm(
      id: number,
      idForm: number,
      body?: any,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .updateForm(id, idForm, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
export class ReportsApi extends BaseAPI {
  /**
   *
   * @param {number} id
   * @param {boolean} [printPhotos]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public _export(id: number, printPhotos?: boolean, options?: any) {
    return ReportsApiFp(this.configuration)
      ._export(id, printPhotos, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} [filter]
   * @param {boolean} [closed]
   * @param {boolean} [myReports]
   * @param {string} [orderBy]
   * @param {boolean} [descending]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public apiReportsGet(
    filter?: string,
    closed?: boolean,
    myReports?: boolean,
    orderBy?: string,
    descending?: boolean,
    options?: any
  ) {
    return ReportsApiFp(this.configuration)
      .apiReportsGet(filter, closed, myReports, orderBy, descending, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public apiReportsIdDelete(id: number, options?: any) {
    return ReportsApiFp(this.configuration)
      .apiReportsIdDelete(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public apiReportsIdGet(id: number, options?: any) {
    return ReportsApiFp(this.configuration)
      .apiReportsIdGet(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {number} idNote
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public apiReportsIdNoteIdNoteDelete(
    id: number,
    idNote: number,
    options?: any
  ) {
    return ReportsApiFp(this.configuration)
      .apiReportsIdNoteIdNoteDelete(id, idNote, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {number} idNote
   * @param {EditNoteCommand} [editNoteCommand]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public apiReportsIdNoteIdNotePut(
    id: number,
    idNote: number,
    editNoteCommand?: EditNoteCommand,
    options?: any
  ) {
    return ReportsApiFp(this.configuration)
      .apiReportsIdNoteIdNotePut(id, idNote, editNoteCommand, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {AddNoteCommand} [addNoteCommand]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public apiReportsIdNotePost(
    id: number,
    addNoteCommand?: AddNoteCommand,
    options?: any
  ) {
    return ReportsApiFp(this.configuration)
      .apiReportsIdNotePost(id, addNoteCommand, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public apiReportsIdPhotorecordGet(id: number, options?: any) {
    return ReportsApiFp(this.configuration)
      .apiReportsIdPhotorecordGet(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {number} idPhoto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public apiReportsIdPhotorecordIdPhotoDelete(
    id: number,
    idPhoto: number,
    options?: any
  ) {
    return ReportsApiFp(this.configuration)
      .apiReportsIdPhotorecordIdPhotoDelete(id, idPhoto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {number} idPhoto
   * @param {EditPhotoRecordCommand} [editPhotoRecordCommand]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public apiReportsIdPhotorecordIdPhotoPut(
    id: number,
    idPhoto: number,
    editPhotoRecordCommand?: EditPhotoRecordCommand,
    options?: any
  ) {
    return ReportsApiFp(this.configuration)
      .apiReportsIdPhotorecordIdPhotoPut(
        id,
        idPhoto,
        editPhotoRecordCommand,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {string} [label]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public apiReportsIdPhotorecordPost(
    id: number,
    label?: string,
    options?: any
  ) {
    return ReportsApiFp(this.configuration)
      .apiReportsIdPhotorecordPost(id, label, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} id
   * @param {UpdateReportCommand} [updateReportCommand]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public apiReportsIdPut(
    id: string,
    updateReportCommand?: UpdateReportCommand,
    options?: any
  ) {
    return ReportsApiFp(this.configuration)
      .apiReportsIdPut(id, updateReportCommand, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {CreateReportCommand} [createReportCommand]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public apiReportsPost(
    createReportCommand?: CreateReportCommand,
    options?: any
  ) {
    return ReportsApiFp(this.configuration)
      .apiReportsPost(createReportCommand, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} reportId
   * @param {number} checkListId
   * @param {number} [newValue]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public bulkUpdateChecks(
    reportId: number,
    checkListId: number,
    newValue?: number,
    options?: any
  ) {
    return ReportsApiFp(this.configuration)
      .bulkUpdateChecks(reportId, checkListId, newValue, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} reportId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public completeReport(reportId: number, options?: any) {
    return ReportsApiFp(this.configuration)
      .completeReport(reportId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {number} idForm
   * @param {any} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportsApi
   */
  public updateForm(id: number, idForm: number, body?: any, options?: any) {
    return ReportsApiFp(this.configuration)
      .updateForm(id, idForm, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SignaturesApi - axios parameter creator
 * @export
 */
export const SignaturesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} [filter]
     * @param {number} [reportConfigurationId]
     * @param {number} [reportId]
     * @param {boolean} [inConfigurationOnly]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSignaturesGet: async (
      filter?: string,
      reportConfigurationId?: number,
      reportId?: number,
      inConfigurationOnly?: boolean,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/Signatures`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter
      }

      if (reportConfigurationId !== undefined) {
        localVarQueryParameter['reportConfigurationId'] = reportConfigurationId
      }

      if (reportId !== undefined) {
        localVarQueryParameter['reportId'] = reportId
      }

      if (inConfigurationOnly !== undefined) {
        localVarQueryParameter['inConfigurationOnly'] = inConfigurationOnly
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSignaturesIdDelete: async (
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiSignaturesIdDelete', 'id', id)
      const localVarPath = `/api/Signatures/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSignaturesIdGet: async (
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiSignaturesIdGet', 'id', id)
      const localVarPath = `/api/Signatures/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {EditSignatureCommand} [editSignatureCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSignaturesIdPut: async (
      id: number,
      editSignatureCommand?: EditSignatureCommand,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiSignaturesIdPut', 'id', id)
      const localVarPath = `/api/Signatures/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        editSignatureCommand,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {AddSignatureCommand} [addSignatureCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSignaturesPost: async (
      addSignatureCommand?: AddSignatureCommand,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/Signatures`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        addSignatureCommand,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SignaturesApi - functional programming interface
 * @export
 */
export const SignaturesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    SignaturesApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {string} [filter]
     * @param {number} [reportConfigurationId]
     * @param {number} [reportId]
     * @param {boolean} [inConfigurationOnly]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiSignaturesGet(
      filter?: string,
      reportConfigurationId?: number,
      reportId?: number,
      inConfigurationOnly?: boolean,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<SignatureDto>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiSignaturesGet(
          filter,
          reportConfigurationId,
          reportId,
          inConfigurationOnly,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiSignaturesIdDelete(
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiSignaturesIdDelete(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiSignaturesIdGet(
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiSignaturesIdGet(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {EditSignatureCommand} [editSignatureCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiSignaturesIdPut(
      id: number,
      editSignatureCommand?: EditSignatureCommand,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiSignaturesIdPut(
          id,
          editSignatureCommand,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {AddSignatureCommand} [addSignatureCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiSignaturesPost(
      addSignatureCommand?: AddSignatureCommand,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiSignaturesPost(
          addSignatureCommand,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * SignaturesApi - factory interface
 * @export
 */
export const SignaturesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SignaturesApiFp(configuration)
  return {
    /**
     *
     * @param {string} [filter]
     * @param {number} [reportConfigurationId]
     * @param {number} [reportId]
     * @param {boolean} [inConfigurationOnly]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSignaturesGet(
      filter?: string,
      reportConfigurationId?: number,
      reportId?: number,
      inConfigurationOnly?: boolean,
      options?: any
    ): AxiosPromise<Array<SignatureDto>> {
      return localVarFp
        .apiSignaturesGet(
          filter,
          reportConfigurationId,
          reportId,
          inConfigurationOnly,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSignaturesIdDelete(id: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .apiSignaturesIdDelete(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSignaturesIdGet(id: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .apiSignaturesIdGet(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {EditSignatureCommand} [editSignatureCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSignaturesIdPut(
      id: number,
      editSignatureCommand?: EditSignatureCommand,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .apiSignaturesIdPut(id, editSignatureCommand, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {AddSignatureCommand} [addSignatureCommand]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSignaturesPost(
      addSignatureCommand?: AddSignatureCommand,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .apiSignaturesPost(addSignatureCommand, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * SignaturesApi - object-oriented interface
 * @export
 * @class SignaturesApi
 * @extends {BaseAPI}
 */
export class SignaturesApi extends BaseAPI {
  /**
   *
   * @param {string} [filter]
   * @param {number} [reportConfigurationId]
   * @param {number} [reportId]
   * @param {boolean} [inConfigurationOnly]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SignaturesApi
   */
  public apiSignaturesGet(
    filter?: string,
    reportConfigurationId?: number,
    reportId?: number,
    inConfigurationOnly?: boolean,
    options?: any
  ) {
    return SignaturesApiFp(this.configuration)
      .apiSignaturesGet(
        filter,
        reportConfigurationId,
        reportId,
        inConfigurationOnly,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SignaturesApi
   */
  public apiSignaturesIdDelete(id: number, options?: any) {
    return SignaturesApiFp(this.configuration)
      .apiSignaturesIdDelete(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SignaturesApi
   */
  public apiSignaturesIdGet(id: number, options?: any) {
    return SignaturesApiFp(this.configuration)
      .apiSignaturesIdGet(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {EditSignatureCommand} [editSignatureCommand]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SignaturesApi
   */
  public apiSignaturesIdPut(
    id: number,
    editSignatureCommand?: EditSignatureCommand,
    options?: any
  ) {
    return SignaturesApiFp(this.configuration)
      .apiSignaturesIdPut(id, editSignatureCommand, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {AddSignatureCommand} [addSignatureCommand]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SignaturesApi
   */
  public apiSignaturesPost(
    addSignatureCommand?: AddSignatureCommand,
    options?: any
  ) {
    return SignaturesApiFp(this.configuration)
      .apiSignaturesPost(addSignatureCommand, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {UserDto} [userDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUser: async (
      userDto?: UserDto,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/Users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        userDto,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Change User Password after validated
     * @param {string} userName
     * @param {ChangePasswordDto} [changePasswordDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword: async (
      userName: string,
      changePasswordDto?: ChangePasswordDto,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userName' is not null or undefined
      assertParamExists('changePassword', 'userName', userName)
      const localVarPath = `/api/Users/{userName}`.replace(
        `{${'userName'}}`,
        encodeURIComponent(String(userName))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        changePasswordDto,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} userName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (
      userName: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userName' is not null or undefined
      assertParamExists('deleteUser', 'userName', userName)
      const localVarPath = `/api/Users/{userName}`.replace(
        `{${'userName'}}`,
        encodeURIComponent(String(userName))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActiveUser: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/Users/active`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} userName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserByUserName: async (
      userName: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userName' is not null or undefined
      assertParamExists('getUserByUserName', 'userName', userName)
      const localVarPath = `/api/Users/{userName}`.replace(
        `{${'userName'}}`,
        encodeURIComponent(String(userName))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/Users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} userName
     * @param {UserDto} [userDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: async (
      userName: string,
      userDto?: UserDto,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userName' is not null or undefined
      assertParamExists('updateUser', 'userName', userName)
      const localVarPath = `/api/Users/{userName}`.replace(
        `{${'userName'}}`,
        encodeURIComponent(String(userName))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication jwt_auth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        userDto,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {UserDto} [userDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addUser(
      userDto?: UserDto,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addUser(
        userDto,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Change User Password after validated
     * @param {string} userName
     * @param {ChangePasswordDto} [changePasswordDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changePassword(
      userName: string,
      changePasswordDto?: ChangePasswordDto,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(
        userName,
        changePasswordDto,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {string} userName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(
      userName: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(
        userName,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getActiveUser(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveUser(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {string} userName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserByUserName(
      userName: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUserByUserName(userName, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsers(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {string} userName
     * @param {UserDto} [userDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUser(
      userName: string,
      userDto?: UserDto,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(
        userName,
        userDto,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UsersApiFp(configuration)
  return {
    /**
     *
     * @param {UserDto} [userDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUser(userDto?: UserDto, options?: any): AxiosPromise<User> {
      return localVarFp
        .addUser(userDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Change User Password after validated
     * @param {string} userName
     * @param {ChangePasswordDto} [changePasswordDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword(
      userName: string,
      changePasswordDto?: ChangePasswordDto,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .changePassword(userName, changePasswordDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} userName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(userName: string, options?: any): AxiosPromise<User> {
      return localVarFp
        .deleteUser(userName, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActiveUser(options?: any): AxiosPromise<UserDto> {
      return localVarFp
        .getActiveUser(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} userName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserByUserName(userName: string, options?: any): AxiosPromise<UserDto> {
      return localVarFp
        .getUserByUserName(userName, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(options?: any): AxiosPromise<Array<UserDto>> {
      return localVarFp
        .getUsers(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} userName
     * @param {UserDto} [userDto]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(
      userName: string,
      userDto?: UserDto,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .updateUser(userName, userDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   *
   * @param {UserDto} [userDto]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public addUser(userDto?: UserDto, options?: any) {
    return UsersApiFp(this.configuration)
      .addUser(userDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Change User Password after validated
   * @param {string} userName
   * @param {ChangePasswordDto} [changePasswordDto]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public changePassword(
    userName: string,
    changePasswordDto?: ChangePasswordDto,
    options?: any
  ) {
    return UsersApiFp(this.configuration)
      .changePassword(userName, changePasswordDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} userName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public deleteUser(userName: string, options?: any) {
    return UsersApiFp(this.configuration)
      .deleteUser(userName, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getActiveUser(options?: any) {
    return UsersApiFp(this.configuration)
      .getActiveUser(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} userName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUserByUserName(userName: string, options?: any) {
    return UsersApiFp(this.configuration)
      .getUserByUserName(userName, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUsers(options?: any) {
    return UsersApiFp(this.configuration)
      .getUsers(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} userName
   * @param {UserDto} [userDto]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public updateUser(userName: string, userDto?: UserDto, options?: any) {
    return UsersApiFp(this.configuration)
      .updateUser(userName, userDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
